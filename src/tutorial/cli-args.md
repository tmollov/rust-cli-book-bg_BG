# Анализиране на аргументите подадени на командния ред

Типично извикване на нашия CLI инструмент ще изглежда така:

```console
grrs foobar test.txt
```

Очакваме нашата програма да разгледа файла `test.txt`
и отпечатва редовете, които съдържат `foobar`.
Но как да получим тези две стойности?

Текстът след името на програмата често се нарича
"аргументите на командния ред",
или "флагове на командния ред"
(особено когато изглеждат така `--this`).
Вътрешно операционната система обикновено ги представлява
като списък от низове –
грубо казано, те се разделят с интервали.

Има много начини да мислим за тези аргументи,
и как да ги анализираме
в нещо по-лесно за работа.
В същото време ще трябва да кажете на потребителите на вашата програма
какви аргументи трябва да дадат
и в какъв формат и ред се очакват.

## Получаване на аргументи

Стандартната библиотека съдържа функцията
[`std::env::args()`], която връща [итератор] на дадените аргументи.
Първият запис (в индекс `0`) ще бъде името, с което е наречена вашата програма (напр. `grrs`),
тези, които следват, са написани от потребителя.

[`std::env::args()`]: https://doc.rust-lang.org/1.39.0/std/env/fn.args.html
[итератор]: https://doc.rust-lang.org/1.39.0/std/iter/index.html

Получаването на суровите аргументи по този начин е доста лесно (в `src/main.rs` файла, след функцията `fn main() {`):

```rust,ignore
{{#include cli-args-struct.rs:10:11}}
```

## CLI аргументите като тип данни

Вместо да мислим за тях като за куп текст,
често си струва да ги мислим като персонализиран тип данни
, които представляват входовете към вашата програма.

Вижте `grrs foobar test.txt`:
Има два аргумента,
първото е `pattern` (шаблон от низ, който търсим),
и след това `path` (път към файл, в който да погледнем).

Какво повече можем да кажем за тях?
Е, като за начало и двете са необходими.
Не сме говорили за никакви стойности по подразбиране,
така че очакваме нашите потребители винаги да предоставят две стойности.
Освен това можем да кажем малко за техните видове:
Шаблонът трябва да е низ,
докато втория аргумент трябва да е пътя до даден файл.

В Rust, обичайно е програмите да се структурират около данните, които обработват, така че този
начин за разглеждане на CLI аргументите пасва много добре. Да започнем с това
(в `src/main.rs` файл , преди функцията `fn main() {`):

```rust,ignore
{{#include cli-args-struct.rs:3:7}}
```

Това определя нова структура ([`struct`])
който има две полета за съхраняване на данни: `pattern`, and `path`.

[`struct`]: https://doc.rust-lang.org/1.39.0/book/ch05-00-structs.html

<aside>

**Забележка:**
[`PathBuf`] е нещо като [`String`] но за пътища на файловата система, които работят между различни платформи.

[`PathBuf`]: https://doc.rust-lang.org/1.39.0/std/path/struct.PathBuf.html
[`String`]: https://doc.rust-lang.org/1.39.0/std/string/struct.String.html

</aside>

Сега все още трябва да получим действителните аргументи, които нашата програма е вкарала в тази форма.
Една от възможностите би била ръчно да анализираме списъка с низове, които получаваме от операционната система
и сами да изградим структурата.
Би изглеждало на нещо подобно:

```rust,ignore
{{#include cli-args-struct.rs:10:15}}
```

Това работи, но не е много удобно.
Как бихте се справили с изискването за поддържане на
`--pattern="foo"` или `--pattern "foo"`?
Как бихте имплементирали `--help`?

## Обработване на CLI аргументи с Clap

Много по-добър начин е да използвате една от многото налични библиотеки.
Най-популярната библиотека за анализиране на аргументи от командния ред
се нарича [`clap`].
Има цялата функционалност, която бихте очаквали,
включително поддръжка за подкоманди, [shell предложения], и страхотни помощни съобщения.

[`clap`]: https://docs.rs/clap/
[shell предложения]: https://docs.rs/clap_complete/

Нека първо да вмъкваме `clap` като добавим
`clap = { version = "4.0", features = ["derive"] }` към `[dependencies]` секцията
на нашия `Cargo.toml` файл.

Сега можем да напишем `use clap::Parser;` в кода ни,
и да добавим `#[derive(Parser)]` над `struct Cli`.
Нека също да напишем някои коментари към документацията по това време.

Ще изглежда така (в `src/main.rs` файла, преди функцията `fn main() {`):

```rust,ignore
{{#include cli-args-clap.rs:3:12}}
```

<aside class="node">

**Забележка:**
Има много персонализирани атрибути, които можете да добавите към полетата.
Например,
за да кажете, че искате да използвате това поле за аргумента след `-o` или `--output`,
трябва да добавите `#[arg(short = 'o', long = "output")]`.
За повече информация,
погледнете [документацията за clap][`clap`].

</aside>

Точно под `Cli` структурата нашият шаблон съдържа функцията `main`.
Когато програмата стартира, тя ще извика тази функция.
Първият ред е:

```rust,ignore
{{#include cli-args-clap.rs:14:16}}
```

Това ще се опита да анализира и прилага аргументите в структурата `Cli` .

Но какво ще стане, ако това се провали?
Това е красотата на този подход:
``Clap`` знае кои полета да очаква,
и какъв е очакваният им формат.
Може автоматично да генерира хубав `--help` съобщение,
както и да даде някои големи грешки,
да ви предложи правилния аргумент, например `--output` когато сте написали `--putput`.

<aside class="note">

**Забележка:**
Метода `parse` е предназначен да се използва във функцията `main`.
Когато се провали,
ще отпечата съобщение за грешка или помощ
и веднага ще излезе от програмата.
Не го използвайте на други места!

</aside>

## Обобщение

Вашият код трябва да изглежда така:

```rust,ignore
{{#include cli-args-clap.rs}}
```

Изпълняването на програмката ни без никакви аргументи трябва да изглежда така:

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 10.16s
     Running `target/debug/grrs`
error: The following required arguments were not provided:
    <pattern>
    <path>

USAGE:
    grrs <pattern> <path>

For more information try --help
```

Можем да предаваме аргументи, когато използваме `cargo run` директно и ги напишете след  `--`:

```console
$ cargo run -- some-pattern some-file
    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
     Running `target/debug/grrs some-pattern some-file`
```

Както виждате,
програмката не връща нищо.
Което е добре:
Това означава, че няма грешка и програмата ни се изпълни и приключи успешно.

<aside class="exercise">

**Упражнение за читателите:**
Накарайте тази програма да извежда своите аргументи!

</aside>
