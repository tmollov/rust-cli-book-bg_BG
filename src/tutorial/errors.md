# По-добро отчитане на грешки

Всички ние не можем да направим нищо, освен да приемем факта, че ще се появят грешки.
И за разлика от много други езици,
много е трудно да не забележиш и да не се справиш с тази реалност
когато използваш Rust:
Тъй като няма изключения,
всички възможни състояния на грешките често са кодирани в типа, което функцията връща.

## Типът Result

Функция като [`read_to_string`] не връща низ.
Вместо това то връща [`Result`]
, което съдържа или `String`
, или грешка от някакъв вид
(в този случай [`std::io::Error`]).

[`read_to_string`]: https://doc.rust-lang.org/1.39.0/std/fs/fn.read_to_string.html
[`Result`]: https://doc.rust-lang.org/1.39.0/std/result/index.html
[`std::io::Error`]: https://doc.rust-lang.org/1.39.0/std/io/type.Result.html

Как разбираме кое е от двете?
Тъй като `Result` е от тип `enum`,
може да използваме `match`, за да проверите кой от двете варианта е:

```rust,no_run
let result = std::fs::read_to_string("test.txt");
match result {
    Ok(content) => { println!("File content: {}", content); }
    Err(error) => { println!("Oh noes: {}", error); }
}
```

<aside>

**Забележка:**
Не сте сигурен какво представляват `enum` и как работят в Rust?
[Вижте тази глава от книгата за Rust](https://doc.rust-lang.org/1.39.0/book/ch06-00-enums.html)
, за да сте в крак с този наръчник.

</aside>

## Разопаковане - Unwrapping

Сега успяхме да получим достъп до съдържанието на файла,
но всъщност не можем да направим нищо с него след `match` блока.
За това ще трябва по някакъв начин да се справим при случай на грешка.
Предизвикателството е, че всички потоци на изпълнението на блока `match` трябва да връщат нещо от същия тип.
Но има хитър трик, за да го заобиколите:

```rust,no_run
let result = std::fs::read_to_string("test.txt");
let content = match result {
    Ok(content) => { content },
    Err(error) => { panic!("Can't deal with {}, just exit here", error); }
};
println!("file content: {}", content);
```

Може да използвате `String`-а от `content` след `match` блока.
Ако `result` дава грешка, `String` няма да съществува.
Но тъй като програмата щеше да излезе, преди да достигне тази точката, в която използваме `content`,
това е възможно.

Това може да изглежда драстично,
но е много удобно.
Ако вашата програма трябва да прочете този файл и не може да направи нищо, ако файлът не съществува,
излизането е валидна стратегия.
Има дори включен метод за бърз достъп на `Result`-та, която се нарича `unwrap`:

```rust,no_run
let content = std::fs::read_to_string("test.txt").unwrap();
```

## Няма нужда от `panic`

Разбира се, прекъсването на програмата не е единственият начин за справяне с грешките.
Вместо  `panic!`, ние също можем лесно да напишем `return`:

```rust,no_run
# fn main() -> Result<(), Box<dyn std::error::Error>> {
let result = std::fs::read_to_string("test.txt");
let content = match result {
    Ok(content) => { content },
    Err(error) => { return Err(error.into()); }
};
# Ok(())
# }
```

Това обаче променя типа, която се връща, от който се нуждае нашата функция.
Наистина имаше нещо скрито в нашите примери през цялото това време:
Сигнатурата на функцията, в която живее този код.
И в този последен пример с `return`,
тo става важно.
Ето и _целият_ пример:

```rust,no_run
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let result = std::fs::read_to_string("test.txt");
    let content = match result {
        Ok(content) => { content },
        Err(error) => { return Err(error.into()); }
    };
    println!("file content: {}", content);
    Ok(())
}
```

Нашият тип, който връщаме е `Result`!
Ето защо можем да пишем `return Err(error);` във вторя поток на `match`.
Вижте как има `Ok(())` най-отдолу?
Това е върнатата стойност по подразбиране на функцията и означава че
"Result е правилно, и няма съдържание".

<aside>

**Забележка:**
Защо това не е написано като `return Ok(());`?
Лесно може да бъде – това също е напълно валидно.
Последният израз на всеки блок в Rust е стойността, която връща,
и е обичайно да се пропуска ненужния `return`.

</aside>

## Въпросителен знак

Също като извикването на функцията `.unwrap()` е пряк път
за `match` с `panic!` в потока за грешки,
имаме друг пряк път за `match`, което връща стойността `return` на потока за грешки:
`?`.

Точно така - въпросителния знак.
Можете да добавите този оператор към стойност на типа `Result`,
и Rust вътрешно ще разшири това до нещо много подобно на
`match` блока, което написахме.

Опитайте го:

```rust,no_run
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let content = std::fs::read_to_string("test.txt")?;
    println!("file content: {}", content);
    Ok(())
}
```

Много е сбито!

<aside>

**Забележка:**
Тук се случват още няколко неща
, което не е нужно да разбирате, за да работите с тях.
Например,
типа грешка в нашия `main` функция е `Box<dyn std::error::Error>`.
Но ние видяхме по-горе това `read_to_string`, че връща [`std::io::Error`].
Това работи, защото `?` се разширява до код, което  _превръща_ типовете грешки.

`Box<dyn std::error::Error>` също е интересен тип.
Това е контейнер - `Box`, което може да съдържа _всякакъв_ тип
който прилага стандартния тип [`Error trait`][`std::error::Error`].
Това означава, че по принцип всички грешки могат да бъдат поставени в това поле,
така че можем да използваме `?` на всички обичайни функции, които връщат `Result` типа.

[`std::error::Error`]: https://doc.rust-lang.org/1.39.0/std/error/trait.Error.html

</aside>

## Осигуряване на контекст

Грешките, които получавате, когато използвате `?` във вашата `main` функция, са наред,
но не са страхотни.
Например:
Когато изпълним `std::fs::read_to_string("test.txt")?`
но файла `test.txt` не съществува,
получавате този резултат:

```text
Error: Os { code: 2, kind: NotFound, message: "No such file or directory" }
```

В случаите, когато вашият код не съдържа буквално името на файла,
би било много трудно да се каже кой файл не е намерен.
Има много начини да се справите с това.

Например, можем да създадем наш собствен тип грешка,
и след това да използваме това, за да създадем персонализирано съобщение за грешка:

```rust,ignore
{{#include errors-custom.rs}}
```

Сега,
изпълнявайки това, ще получим нашето персонализирано съобщение за грешка:

```text
Error: CustomError("Error reading `test.txt`: No such file or directory (os error 2)")
```

Не е много приятно,
но можем лесно да адаптираме изхода за отстраняване на грешки за нашия тип по-късно.

Този шаблон всъщност е срещан доста често.
Обаче има един проблем:
Ние не съхраняваме оригиналната грешка,
само неговото низово представяне.
Често използваната [`anyhow`] библеотека има чудесно решение за този проблем:
подобно на нашия `CustomError` тип,
неговия [`Context trait`] може да се използва за добавяне на описание.
Освен това запазва и оригиналната грешка,
така че получаваме "верига" от съобщения за грешката, посочващи коренната причина.

[`anyhow`]: https://docs.rs/anyhow
[`Context trait`]: https://docs.rs/anyhow/1.0/anyhow/trait.Context.html

Нека да вмъкнем `anyhow` библеотеката като добавим
`anyhow = "1.0"` в `[dependencies]` секцията
в файла `Cargo.toml`.

Тогава пълният пример би изглеждало така:

```rust,ignore
{{#include errors-exit.rs}}
```

Това ще отпечата грешката:

```text
Error: could not read file `test.txt`

Caused by:
    No such file or directory (os error 2)
```
