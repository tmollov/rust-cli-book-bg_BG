# Тестване

В продължение на десетилетия разработка на софтуер,
хората са открили една истина:
Нетестваният софтуер рядко работи.
(Много хора биха стигнали дотам, че да кажат:
„Повечето тестван софтуер също не работи.“
Но тук всички сме оптимисти, нали?)
Така че, за да сте сигурни, че вашата програма прави това, което очаквате да прави,
разумно е да го тествате.

Един лесен начин да направите това е
да напишете `README` файл
който описва какво трябва да прави вашата програма.
И когато се почувствате готови да направите ново издание,
преминете през `README` файла и гарантирайте това
поведението все още е според очакванията.
Можете да направите това по-строго упражнение
като също така запишете как вашата програма трябва да реагира на грешни входове.

Ето още една интересна идея:
Напишете `README` файла преди да напишете кода.

<aside>

**Забележка:**
Погледнете на
[Test-Driver Development] (TDD)
ако не сте чували за него.

[Test-Driver Development]: https://dev.bg/digest/test-driven-development/

</aside>

## Автоматизирано тестване

Сега, всичко това е чудесно,
но да направите всичко това ръчно?
Това може да отнеме много време.
По същото време,
много хора започнаха да изпитват удоволствие да казват на компютрите да правят неща вместо тях.
Нека поговорим как да автоматизираме тези тестове.

Rust има вградена тестов `framework`
така че нека започнем с написването на първия ни тест:

```rust,ignore
# fn answer() -> i32 {
#   42
# }
#
#[test]
fn check_answer_validity() {
    assert_eq!(answer(), 42);
}
```

Можете да поставите този кодов фрагмент в почти всеки файл
и `cargo test` ще намери
и ще го изпълни.
Ключът тук е `#[test]` атрибутът.
Това позволява на системата за изграждане да открие такива функции
и да ги изпълни като тестове,
проверявайки дали са коректни.

<aside class="exercise">

**Упражнение за читателя:**
Накарайте този тест да проработи.

Трябва да получите резултат като следния:

```text
running 1 test
test check_answer_validity ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

</aside>

Сега, след като видяхме *как* можем да пишем тестове,
все още трябва да разберем *какво* да тестваме.
Както видяхте, е доста лесно да се пишат твърдения
за функции.
Но едно CLI приложение често има повече от една функция!
По-лошото е, че то често се занимава с входните данни от потребителя,
четене от файлове
и изваждане на резултат.

## Направете кода си годен за тестване

Има два допълващи се подхода за тестване на функционалността:
Тестване малки единици, от които изграждате цялото си приложение,
които се наричат "unit tests".
И също така и тестване на готовото приложение "от външната страна"
наречено още "black box tests" или "integration tests" (интеграционни тестове).
Нека да започнем с първия.

За да разберем какво трябва да тестваме,
нека да видим какви са функциите на нашата програма.
Главно, `grrs` трябва да отпечата редовете, които отговарят на даден шаблон.
И така, нека да напишем `unit` тестове *точно за това*:
Искаме да сме сигурни, че нашата най-важна част от логиката работи
и искаме да го направим по начин, който е независим
от всеки код за настройка, който имаме около него
(който се занимава с CLI аргументи, например).

Връщайки се към нашата [първа имплементация](impl-draft.md) на `grrs`,
добавихме този блок код към функцията `main`:

```rust,ignore
// ...
for line in content.lines() {
    if line.contains(&args.pattern) {
        println!("{}", line);
    }
}
```

За съжаление, това не е много лесно за тестване.
Първо, това е в основната функция, така че не можем лесно да го извикаме.
Това лесно се коригира чрез преместване на тази част от кода във функция:

```rust,no_run
fn find_matches(content: &str, pattern: &str) {
    for line in content.lines() {
        if line.contains(pattern) {
            println!("{}", line);
        }
    }
}
```

Сега можем да извикаме тази функция в нашия тест,
и да видим какъв е изходът му:

```rust,ignore
#[test]
fn find_a_match() {
    find_matches("lorem ipsum\ndolor sit amet", "lorem");
    assert_eq!( // uhhhh
```

Или… можем ли?
В момента, `find_matches` отпечатва директно към `stdout`, т.е. в терминала.
Не можем лесно да уловим това в тест!
Това е проблем, който често се появява
когато пишете тестове след имплементацията на логиката:
Написахме функция, която е здраво интегрирана
в контекста, в който се използва.

<aside class="note">

**Забележка:**
Това е напълно правилно, когато пишете малки CLI приложения.
Няма нужда всичко да е тестваем!
Важно е да се мисли за
кои части от кода си обаче бихте искали да напишете `unit` тестове.
Въпреки че ще видим, че е лесно да промените тази функция, за да бъде тествана,
това не винаги ще е случая.

</aside>

Добре, как можем да направим това тестваем?
Ще трябва някак да уловим резултата.
Стандартната библеотека на Rust има някои чисти абстракции
за работа с I/O (вход/изход)
и ние ще използваме един наречен [`std::io::Write`].
Това е [trait][trpl-traits] абстрахираща над нещата, за които можем да пишем,
което включва низове, но също така `stdout`.

[trpl-traits]: https://doc.rust-lang.org/book/ch10-02-traits.html
[`std::io::Write`]: https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html

Ако за първи път чувате думичката "trait"
в контекста на Rust,
трябва се обогатите.
`Trait`-овете са са една от най-мощните характеристики на Rust.
Можете да мислите за тях като за интерфейсите в Java,
или типа 'classes' в езика Haskell
(с каквото сте по-запознати).
Те ви позволяват да се абстрахирате от поведението
които могат да се споделят от различни типове.
Кодът, който използва `trait`, могат да
изразяват идеите си по много общи и гъвкави начини.
Това обаче означава, че може да стане трудно за четене.
Не позволявайте на това да ви плаши:
Дори хора, които са използвали Rust от години
не разбират веднага какво прави генеричния код.
А в този случай,
помага да се мисли за конкретни употреби.
Например,
в нашия случай,
поведението, което абстрахираме, е "пиши му / записване".
Примери за типовете, които го имплементират ("impl")
са :
Стандартния изход на терминала,
файлове,
буфера в паметта,
или интернет връзка чрез протокола `TCP`.
(Скролнете надолу в [документацията за `std::io::Write`][`std::io::Write`]
за да видите списък с "Имплементаторите".)

С това знание,
нека променим нашата функция, за да приеме трети параметър.
Трябва да е от всякакъв тип, който изпълнява `Write`.
По този начин,
можем да предоставим прост низ
в нашите тестове
и да направим твърдения по него.
Ето как можем да напишем тази версия на функцията `find_matches`:

```rust,ignore
{{#include testing/src/main.rs:23:29}}
```

Новия параметър е `mut writer`,
т.е., променливо, което наричаме "writer".
Типът му е `impl std::io::Write`,
което можете да прочетете като
"контейнер за всеки тип, който имплементира `Write trait`".
Също така обърнете внимание как
заменихме `println!(…)`
, което използвахме по-рано
с `writeln!(writer, …)`.
`println!` работи по същия начин като `writeln!`
но винаги използва стандартния изход.

Сега можем да тестваме изхода:

```rust,ignore
{{#include testing/src/main.rs:31:36}}
```

За да използваме това в кода на нашето приложение,
трябва да променим извикването на `find_matches` в функцията `main`
като добавим [`&mut std::io::stdout()`][stdout] като трети параметър.
Ето и пример с основната функция
който се основава на това, което видяхме в предишните глави
и използва нашата извлечена функция `find_matches`:

```rust,ignore
{{#include testing/src/main.rs:13:21}}
```

[stdout]: https://doc.rust-lang.org/1.39.0/std/io/fn.stdout.html

<aside class="note">

**Забележка:**
Тъй като `stdout` очаква байтове,
използваме `std::io::Write` вместо `std::fmt::Write`.
Като резултат,
даваме празен вектор(лист) за "записване на резултатите" в нашия тест
(неговият тип ще бъде `Vec<u8>`),
в `assert_eq!` използваме `b"foo"`.
(Префикса `b` го превръща в *байтов низов литерал*
така че неговият тип ще бъде `&[u8]` вместо `&str`).

</aside>

<aside class="note">

**Забележка:**
Можем също да накараме тази функция да връща `String`,
но това би променило поведението му.
Вместо да изпринтира директно на терминала,
това ще събере всичко в низ,
и ще извади целия резултат наведнъж в края.

</aside>

<aside class="exercise">

**Упражнение за читателя:**
[`writeln!`] връща [`io::Result`]
защото писането може да се провали,
например когато буферът е пълен и не може да бъде разширен.
Добавяне на обработка на грешки към функцията `find_matches`.

[`writeln!`]: https://doc.rust-lang.org/1.39.0/std/macro.writeln.html
[`io::Result`]: https://doc.rust-lang.org/1.39.0/std/io/type.Result.html

</aside>

Току-що видяхме как да направим тази част от кода лесна за тестване.
Имаме

1. идентифицирахме една от основните части на нашето приложение,
2. поставихме го в неговата собствена функция,
3. и го направихме по-гъвкав.

Въпреки че целта беше да го направим тестван,
резултатът, до който стигнахме
всъщност е много идиоматично и многократно използвано парче от Rust кода.
Това е страхотно!

## Разделяне на вашия код на библиотечни и изпълняеми цели

Тук можем да направим още нещо.
Досега сме поставили всичко, което сме написали в файла `src/main.rs`.
Това означава, че текущият ни проект произвежда един изпълняем файл.
Но можем също да направим нашия код достъпен като библиотека, като:

1. Поставяме функцията `find_matches` в нов `src/lib.rs` файл.
2. Добавяме`pub` в началото на `fn` (така че да изглежда така `pub fn find_matches`)
   за да стане нещо, до което потребителите на нашата библиотека да имат достъп.
3. Премахваме `find_matches` от файла `src/main.rs`.
4. И в `fn main` функцията, добавяме повикването към `find_matches` с `grrs::`,
   така че сега да изглежда по този начин: `grrs::find_matches(…)`.
   това означава, че използваме функцията от библиотеката, която току-що написахме!

Начинът, по който Rust се справя с проекти, е доста гъвкав
и е добра идея да помислите
какво да поставите като библеотеката в проекта си още от началото.
Можете, например, да помислите за писане на библиотека
първо за специфична за вашето приложението логика
и след това да го използвате във вашия CLI приложение точно като всяка друга библиотека.
Или, ако вашият проект има множество изпълняеми файлове,
можете да поставите общата функционалност в отделна с библиотечка за проекта.

<aside class="note">

**Забележка:**
Говорейки за поставяне на всичко в файла `src/main.rs`:
Ако продължим да правим това,
ще стане трудно за четене.
[Модулната система] може да ви помогне да структурирате и организирате кода си.

[Модулната система]: https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html

</aside>

## Тестване на CLI приложения чрез стартирането им

Дотук малко се отклонихме от темата
, за да тестваме *бизнес логиката* на нашата програма,
което се оказа функцията `find_matches`.
Това е много ценна
и страхотна първа стъпка
към добре тествана кодова база.
(Обикновено тези видове тестове се наричат "unit" тестове.)

Обаче има много код, който не тестваме:
Всичко, което напишем, за да се справим с външния свят!
Представете си, че сте написали основната функция,
но случайно оставяте твърдо кодиран низ (статичен низ)
вместо да използвате аргумента на предоставения от потребителя път.
Трябва да пишем тестове и за това!
(Това ниво на тестване често се нарича
"интеграционно тестване", или "тестване на система".)

В основата си,
все още пишем функции
и ги анотираме с `#[test]`.
Въпросът е само какво правим вътре в тези функции.
Например, ще искаме да използваме основния изпълняем файл на нашия проект
и да го стартираме като обикновена програма.
Също така ще поставим тези тестове в нов файл в нова директория:
`tests/cli.rs`.

<aside>

**Забележка:**
По конвенция,
`cargo` ще търси интеграционни тестове в `tests/` директорията.
По същия начин,
ще за бенчмарковете в `benches/`,
и за примерите в `examples/`.
Тези конвенции се разпростират и върху вашия основен изходен код:
библеотеките имат `src/lib.rs` файл,
главния изпълням файл е `src/main.rs`,
или, ако има множество такива файлове,
cargo очаква те да бъдат така `src/bin/<name>.rs`.
Следването на тези конвенции ще направи кодовата ви база по-откриваема
от хора, свикнали да четат код на Rust.

</aside>

Да си припомним,
`grrs` е малък инструмент, който търси низ във файл.
Преди това тествахме дали можем да намерим съвпадение.
Нека помислим каква друга функционалност можем да тестваме.

Ето какво измислих.

- Какво се случва, когато файлът не съществува?
- Какъв е резултатът, когато няма съвпадение?
- Програмата ни излиза ли с грешка, когато забравим един (или и двата) аргумента?

Това са всички валидни тестови случаи.
Освен това,
трябва да включим и един тестов случай
за "щастливия път",
т.е. намерихме поне едно съвпадение
и го отпечатваме.

За да улесните тези видове тестове,
ще използваме библеотеката [`assert_cmd`].
Има куп спретнати помощници
, които ни позволяват да изпълняваме основния си изпълняем файл
, за да видим как се държи.
По-нататък,
също ще добавим и библеотеката [`predicates`]
което ни помага да пишем твърдения
, срещу което `assert_cmd` може да тества
(и които имат страхотни съобщения за грешки).
Ще добавим тези зависимости не към основния списък,
но към "dev dependencies" секцията в нашия `Cargo.toml`.
Те са необходими само при разработване на приложението ви,
, а не когато го използвате.

```toml
{{#include testing/Cargo.toml:16:18}}
```

[`assert_cmd`]: https://docs.rs/assert_cmd
[`predicates`]: https://docs.rs/predicates

Това звучи като много за настройване.
Въпреки това –
нека директно да се потопим
и да създадем нашия `tests/cli.rs` файл:

```rust,ignore
{{#include testing/tests/cli.rs:1:15}}
```

Можете да изпълните този тест с
`cargo test`,
точно като тестовете, които написахме по-горе.
Може да отнеме малко повече време първия път,
тъй като `Command::cargo_bin("grrs")` компилира главния ви изпълняем файл.

## Генериране на тестови файлове

Тестът, който току-що видяхме, проверява само дали нашата програма връща съобщение за грешка
когато входният файл не съществува.
Това е важен тест,
но може би не най-важния:
Нека сега да тестваме дали наистина ще отпечатаме съвпаденията, които намерихме във файл!

Ще трябва да имаме файл, чието съдържание знаем,
за да можем да знаем какво *трябва* да върне нашата програма
и да проверим дали е очакваното в нашия код.
Една идея може да е да добавите файл към проекта с персонализирано съдържание
и да го използвате в тестове си.
Друг начин би било да създадем временни файлове в нашите тестове.
За този урок,
ще разгледаме последния подход.
Основно, защото е по-гъвкав и ще работи и в други случаи;
например, когато тествате програми, които променят файловете.

За да създадете тези временни файлове,
ще трябва да използвате библеотеката [`assert_fs`].
Нека го добавим към `dev-dependencies` в нашия `Cargo.toml` файл:

```toml
{{#include testing/Cargo.toml:19}}
```

[`assert_fs`]: https://docs.rs/assert_fs

Ето нов тестов случай
(което можете да напишете под другото)
, в който първо създавате временен файл
("наименуван", за да можем да получим пътя му),
изпълвайте го с някакъв текст,
и след това изпълнете вашата програма
, за да видите дали получаваме правилния резултат.
Когато `file` излиза извън блока
(в края на функцията),
действителният временен файл автоматично ще бъде изтрит.

```rust,ignore
{{#include testing/tests/cli.rs:17:32}}
```

<aside class="exercise">

**Упражнение за читателя:**
Добавете интеграционни тестове за предаване на празен низ като шаблон.
Коригирайте програмата според нуждите.

</aside>

## Какво да тествате?

Въпреки че, със сигурност, може да бъде забавно да се пишат интеграционни тестове,
ще ви отнеме известно време да ги напишете,
както и да ги актуализирате, когато поведението на вашето приложение се промени.
За да сте сигурни, че използвате времето си разумно,
трябва да се запитате какво трябва да тествате.

Като цяло е добра идея да се пишат интеграционни тестове
за всички видове поведения, които потребителят може да наблюдава.
Това означава, че не е необходимо да покривате всички крайни случаи:
Обикновено е достатъчно да има примери за различните типове
и да разчитайте на `unit` тестове, за да покриете крайните случаи.

Също така е добра идея да не фокусирате тестовете си върху неща, които не можете да контролирате активно.
Би било лоша идея да тествате точното оформление на `--help`
тъй като се генерира за вас.
Вместо това може просто да искате да проверите дали определени елементи присъстват.

В зависимост от естеството на вашата програма,
можете също да опитате да добавите още техники за тестване.
Например,
ако сте извлекли части от вашата програма
и установете, че пишете много примерни случаи като `unit` тестове
докато се опитвате да измислите всички крайни случаи,
трябва да разгледате [`proptest`].
Ако имате програма, която използва произволни файлове и ги анализира,
опитайте се да напишете с техниката [fuzzer], за да намирате бъгове в крайните случаи.

[`proptest`]: https://docs.rs/proptest
[fuzzer]: https://rust-fuzz.github.io/book/introduction.html

<aside>

**Забележка:**
Можете да намерите пълния изпълним изходен код, използван в тази глава
[в хранилището на тази книга][src].

[src]: https://github.com/rust-cli/book/tree/master/src/tutorial/testing

</aside>
