# Опаковане и разпространение на Rust инструмент

Ако се чувствате уверени, че вашата програма е готова за използване от други хора,
време е да го опаковате и разпространите!

Има няколко подхода,
и ще разгледаме три от тях
от „най-бърз за настройка“ до „най-удобен за потребителите“.

## Най-бързо: `cargo publish`

Най-лесният начин да публикувате приложението си е с cargo.
Помните ли как добавихме външни зависимости към нашия проект?
Cargoги ги изтегли от стандартната си "регистър за библиотеки", [crates.io].
С `cargo publish`,
вие също можете да публикувате библиотеките си в [crates.io].
И това работи за всички библиотеки,
включително тези с изпълняеми цели.

Публикуване на библиотеки към [crates.io] е доста просто:
Ако все още не сте го направили, създайте акаунт в [crates.io].
В момента това се прави чрез упълномощаване в GitHub,
така че ще трябва да имате акаунт в GitHub
(и да сте влезли там).
След това влизате с cargo на вашата локална машина.
Отидете на
[страницата на акаунта ви в crates.io],
създайте нов токен,
и след това изпълнете `cargo login <your-new-token>`, като "<your-new-token>", е токен-а от вашия акаунт.
Трябва да направите това само веднъж на компютъра си.
Можете да научите повече за това
в [ръководство за публикуване] на cargo.

Сега, когато cargo, както и crates.io ви познават,
вие сте готови да публикувате библиотеките си.
Преди да продължите набързо и да публикувате нова библиотека (версия),
добра идея е да отворите своя `Cargo.toml` още един път
и да се уверите, че сте добавили необходимите метаданни.
Можете да намерите всички възможни полета, които можете да зададете
в документацията за [формата на манифестациите на cargo].
Ето кратък преглед на някои често срещани полета:

```toml
[package]
name = "grrs"
version = "0.1.0"
authors = ["Your Name <your@email.com>"]
license = "MIT OR Apache-2.0"
description = "A tool to search files"
readme = "README.md"
homepage = "https://github.com/you/grrs"
repository = "https://github.com/you/grrs"
keywords = ["cli", "search", "demo"]
categories = ["command-line-utilities"]
```

<aside class="note">

**Забележка:**
Този пример включва задължителното поле за лиценз
обикновенно избран за Rust проекти:
Същият лиценз, който се използва и за самия компилатор.
Също така има референция към файла `README.md`.
Този файл трябва да включва кратко описание на това, за което се отнася вашият проект,
тъй като ще бъде включен не само на страницата в crates.io за вашата библиотека,
но и в страницата на хранилището, което GitHub по подразбиране показва.

</aside>

[crates.io]: https://crates.io/
[страницата на акаунта ви в crates.io]: https://crates.io/me
[ръководство за публикуване]: https://doc.rust-lang.org/1.39.0/cargo/reference/publishing.html
[формата на манифестациите на cargo]: https://doc.rust-lang.org/1.39.0/cargo/reference/manifest.html

### Как да инсталирате изпълняем файл от crates.io

Видяхме как да публикуваме библиотеки в crates.io,
и може би се чудите как да ги инсталирате.
За разлика от библиотеките,
кой cargo ще изтегли и компилира за вас
когато изпълните командата `cargo build` (или подобен такъв),
ще трябва да му кажете да инсталира изрично изпълняемите файлове.

Това се прави с помощта на командата
`cargo install <crate-name>`.
По подразбиране ще изтегли библиотеката,
компилира всички изпълняеми цели, които съдържа
(в "release" режим, така че може да отнеме известно време)
и ще ги копира в директорията `~/.cargo/bin/`.
(Уверете се, че вашата терминал знае да търси там изпълняемите файлове!)

Също така е възможно да
инсталирайте библиотеки от git хранилища,
инсталирайте само конкретни изпълняеми файлове на библиотеките,
и посочете алтернативна директория, в която да ги инсталирате.
Погледнете `cargo install --help` за детайли.

### Кога да го използвате

`cargo install` е лесен начин за инсталиране на изпълняем код.
Много е удобно за разработчиците на Rust да го използват,
но има някои съществени недостатъци:
Тъй като винаги ще компилира вашия източник от нулата,
потребителите на вашия инструмент ще трябва да имат
Rust, cargo, и всички други системни зависимости, които вашият проект изисква
, за да бъдат инсталирани на тяхната машина.
Компилирането на големи кодови бази на Rust също може да отнеме известно време.

Най-добре е да използвате инструменти за разпространение,
които са насочени към други разработчици на Rust.
Например:
Много подкоманди на cargo
като `cargo-tree` или `cargo-outdated`
могат да се инсталират с него.

## Разпространение на изпълняеми файлове

Rust е език, който се компилира в чист код
и по подразбиране свързва статично всички зависимости.
Когато изпълните `cargo build`
на вашия проект, който съдържа изпълняем файл, наречен `grrs`,
ще имате друг изпълняем файл, наречен също по същия начин - `grrs`.
Опитай го:
Когато изпълнявате `cargo build`, то ви генерира:  `target/debug/grrs`,
а когато изпълнявате `cargo build --release`, то ви генерира: `target/release/grrs`.
Освен ако не използвате библиотеки
които изрично се нуждаят от външни библиотеки, които да бъдат инсталирани на целевата система
(като използване на системната версия на OpenSSL),
този изпълняем файл ще зависи само от общи системни библиотеки.
Това означава,
че ако вземете този файл,
и го изпратите на хора, работещи със същата операционна система като вас,
и те ще могат да го стартират.

Това е много мощно!
Работи около два от недостатъците, които току-що видяхме `cargo install`:
Не е необходимо да имате инсталиран Rust на машината на потребителя,
и вместо да отнеме минута за компилиране,
те могат незабавно да стартират изпълняемия файл.

И така, както видяхме,
`cargo build` _вече_  е изградил изпълняемия файлове за нас.
Единственият проблем е,
не е гарантирано, че работят на всички платформи.
Ако стартирате `cargo build` на вашата Windows машина,
няма да получите изпълняем файл, който работи на Mac по подразбиране.
Има ли начин да се генерират тези изпълняеми файлове
за всички интересни платформи
автоматично?

### Изграждане на изпълняеми версии със CI (непрекъсната интеграция)

Ако вашият инструмент е с отворен код
и се хоства на GitHub,
доста лесно е да настроите безплатна услуга за CI (непрекъсната интеграция)
като [Travis CI].
(Има други услуги, които работят и на други платформи, но Travis е много популярен.)
Това основно изпълнява команди за настройка
във виртуална машина
всеки път, когато направите промени във вашето хранилище.
Какви са тези команди,
и типовете машини, на които работят,
са конфигурируеми.
Например:
Добра идея е да изпълните `cargo test`
на машина с Rust, което има инсталирани някои общи инструменти за изграждане.
Ако то се провали,
знаете, че имате проблеми в най-новите промени.

[Travis CI]: https://travis-ci.com/

Можем да използваме и това
за изграждане на изпълняеми файлове и качването им в GitHub!
Всъщност, ако изпълните
`cargo build --release`
и качете изпълняемия файл някъде,
всичко трябва да е готови, нали?
Не точно.
Все още трябва да се уверим, че изпълняемите файлове, които изграждаме
са съвместими с възможно най-много системи.
Например,
в Linux среда можем да компилираме не за текущата система,
но и за `x86_64-unknown-linux-musl`,
за да не зависи от системните библиотеки по подразбиране.
В macOS, можем да зададем стойноста на `MACOSX_DEPLOYMENT_TARGET` да е `10.7`,
за да зависи само от системните функции, присъстващи във версии 10.7 и по-стари.

Можете да видите един пример за изграждане на изпълняеми файлове с помощта на този подход
[тука][wasm-pack-travis] за Linux и macOS
, и [тука][wasm-pack-appveyor] за Windows (използвайки AppVeyor).

[wasm-pack-travis]: https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.travis.yml#L74-L91
[wasm-pack-appveyor]: https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.appveyor.yml

Друг начин е да използвате предварително изградени (Docker) изображения,
които съдържат всички инструменти, от които се нуждаем,
за да изграждаме изпълняеми файлове.
Това ни позволява лесно да се насочваме и към по-екзотични платформи.
Проекта [trust] съдържа
скриптове, които можете да включите във вашия проект
както и инструкции как да ги настроите.
Той също така включва поддръжка за Windows използвайки AppVeyor.

Ако предпочитате да настроите това локално
и da генерирате изходните файловете на вашата собствена машина,
ще е хувабо все пак да погледнете в проекта `trust`.
То вътрешно използва инструмента [cross],
, което работи подобно на cargo
но препраща команди към cargo процеса вътре в Docker контейнера.
Дефинициите на изображенията също са налични в
[хранилището на cross][cross].

[trust]: https://github.com/japaric/trust
[cross]: https://github.com/rust-embedded/cross

### Как да инсталирате тези изпълняеми файлове

Ако насочваме потребителите си към страницата си на изданието
то може да изглежда [подобно на това][wasm-pack-release],
и те могат да изтеглят артефактите, което токущо сме създали.
Артефактите на изданието, които току-що генерирахме, не са нищо особено:
В крайна сметка те са просто архивни файлове, които съдържат нашите изпълняеми файлове!
Това означава, че потребителите на вашия инструмент
могат да ги изтеглят с браузъра си,
да ги разархивират (случва се предимно автоматично),
и да копират тези изпълняеми файлове на място, което им харесва.

[wasm-pack-release]: https://github.com/rustwasm/wasm-pack/releases/tag/v0.5.1

Това изисква известен опит с ръчно "инсталиране" на програми,
така че е хубаво да добавите раздел към вашия README файл,
затова как се инсталира вашата програма.

<aside class="note">

**Забележка:**
Ако използвате [trust] за да изградите вашите изпълняеми файлове и да ги добавите към изданията на Github,
можете също да кажете на хората да изпълняват командата
`curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git your-name/repo-name`
ако смятате, че това го прави по-лесно.

</aside>

### Кога да го използвате

Като цяло наличието на изпълняема версии е добра идея,
едва ли има някакъв недостатък в това.
Това не решава проблема с това, че потребителите трябва да правят ръчно
инсталиране и актуализиране
на вашите инструменти,
но те могат бързо да получат най-новата версия
без да е необходимо да инсталират Rust.

### Какво да пакетирате в допълнение към вашите изпълняеми файлове

В момента,
когато потребител изтегли нашите компилации от тип `release`,
те ще получат `.tar.gz` файл,
което съдържа само изпълняемите файлове.
Така че, в нашия примерен проект,
те ще получат само един `grrs` файл, което могат да го изпълнят.
Но има още няколко файла, дето вече имаме в нашето хранилище,
които някои биха искали да имат.
Този `README` файл, което показва как се използва този инструмент,
и файловете за лиценс,
например.
Тъй като вече ги имаме,
те са лесни за добавяне.

Има още интересни файлове
които имат смисъл особено за инструменти за командния ред,
все пак:
Какво ще кажете да изпратим и страница с ръководство в допълнение към този README файл,
и конфигурационни файлове, които добавят завършвания на възможните флагове към вашия терминал?
Можете да ги напишете на ръка,
но _clap_, библиотеката за разбор на аргументи, която използваме
(на който _clap_ надграждa)
има начин да генерира всички тези файлове за нас.
Погледнете [това в задълбочените теми][clap-man-pages]
за повече детайли.

[clap-man-pages]: ../in-depth/docs.html

## Вкарване на вашето приложение в хранилища на пакети

И двата подхода, които сме виждали досега
не са начинът, по който обикновено инсталирате софтуер на вашата машина.
Особено инструментите за командния ред
ги инсталирате с помощта на глобални мениджъри на пакети
на повечето операционни системи.
Предимствата за потребителите са доста очевидни:
Няма нужда да мислите как да инсталирате вашата програма,
ако може да се инсталира по същия начин, както инсталирате другите инструменти.
Тези мениджъри на пакети също позволяват на потребителите да актуализират своите програми
когато е налична нова версия.

За съжаление, поддържането на различни системи означава
ще трябва да разгледате как работят тези различни системи.
Например,
може да е толкова лесно, колкото добавянето на файл към вашето хранилище
(напр. добавяне на файл с формула като [това][rg-formula] в macOS `brew`),
но за други често ще трябва сами да изпращате пачове
и да добавяте вашия инструмент към техните хранилища.
Има полезни инструменти като
[cargo-bundle](https://crates.io/crates/cargo-bundle),
[cargo-deb](https://crates.io/crates/cargo-deb), и
[cargo-aur](https://crates.io/crates/cargo-aur),
но описвайки как работят
и как опаковат правилно вашия инструмент
за тези различни системи е извън обхвата на тази глава.

[rg-formula]: https://github.com/BurntSushi/ripgrep/blob/31adff6f3c4bfefc9e77df40871f2989443e6827/pkg/brew/ripgrep-bin.rb

Вместо това,
нека да разгледаме инструмент, който е написан на Rust,
което е налично в много различни мениджъри на пакети.

### Например: ripgrep

[ripgrep] е алтернатива на `grep`/`ack`/`ag` и е написан с Rust.
Той е доста успешен и е пакетиран за много операционни системи:
Просто погледнете [секцията "Installation"][rg-install] на README файла му!

Имайте предвид, че той изброява няколко различни опции как можете да го инсталирате:
Започва с връзка към изданията на GitHub
който съдържа изпълняеми файлове, така че можете да ги изтеглите директно;
след това изброява как да го инсталирате с помощта на куп различни мениджъри на пакети;
и накрая, можете също да го инсталирате с помощта на `cargo install`.

Това изглежда като много добра идея:
Не избирайте един от подходите, представени тук,
но започнете с `cargo install`,
добавете изпълняемите издания,
и накрая започнете да разпространявате инструмента си с помощта на системни мениджъри на пакети.

[ripgrep]: https://github.com/BurntSushi/ripgrep
[rg-install]: https://github.com/BurntSushi/ripgrep/tree/31adff6f3c4bfefc9e77df40871f2989443e6827#installation
