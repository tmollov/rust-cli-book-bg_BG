# Изход

## Принтиране на "Hello World"

```rust
println!("Hello World");
```

Е, това беше лесно.
Страхотно, към следващата тема.

## Използване на `println!`

Можете почти да отпечатате всички неща, който харесвате
с т.нар. макро (macro ) функция - `println!`.
Макросите имат някои доста невероятни възможности,
но и специален синтаксис.
Той очаква да напишете низов литерал като първи параметър,
който съдържа контейнери, които ще бъдат попълнени
по стойностите на параметрите, които следват като допълнителни аргументи.

Например:

```rust
let x = 42;
println!("My lucky number is {}.", x);
```

ще изпринтира

```console
My lucky number is 42.
```

Къдравите скоби (`{}`) в горния низ е един от тези контейнери.
Това е типът заместител по подразбиране
който се опитва да отпечата дадената стойност по разбираем за човека начин.
За числа и низове това работи много добре,
но не всички видове могат да направят това.
Ето защо има и "репрезентиране при дебъгване",
който можете да получите, като попълните скобите на контейнера по следния начин: `{:?}`.

Например,

```rust
let xs = vec![1, 2, 3];
println!("The list is: {:?}", xs);
```

Ще изпринтира:

```console
The list is: [1, 2, 3]
```

Ако искате вашите собствени типове данни да могат да се отпечатват за дебъгване и логване,
в повечето случаи можете да добавите `#[derive(Debug)]` над тяхната дефиниция.

<aside>

**Забележка:**
"Потребителско-приятно" изпринтиране се извършва с помощта на [`Display trait`],
изпринтирането при дебъгване (четими за хора, но насочени към разработчиците) използва [`Debug trait`].
Можете да намерите повече информация за синтаксиса, в който можете да използвате в `println!`
в [документацията за модула `std::fmt`][std::fmt].

[std::fmt]: https://doc.rust-lang.org/1.39.0/std/fmt/index.html

</aside>

## Изпринтиране на грешки

Изпринтиране на грешки трябва да се правят чрез `stderr`
за да улеснят потребителите
и другите инструменти
за препращане на техните изходи към файлове
или повече инструменти.

<aside>

**Забележка:**
В повечето операционни системи,
една програма може да пише в два изходни потока, `stdout` и `stderr`.
`stdout` е за действителния изход на програмата,
докато `stderr` позволява грешките и другите съобщения да се съхраняват отделно от `stdout`.
По този начин,
изходът може да бъде съхранен във файл или прехвърлен към друга програма
докато грешките се показват на потребителя.

</aside>

В Rust това се постига
с `println!` и `eprintln!`,
като първия използва `stdout` за изход,
а последния `stderr`.

```rust
println!("This is information");
eprintln!("This is an error! :(");
```

<aside>

**Внимавайте**: Изпринтирането на т.нар. [escape codes] може да е опасно,
поставяйки терминала на потребителя в странно състояние.
Винаги внимавайте, когато ги отпечатвате ръчно!

[escape codes]: https://en.wikipedia.org/wiki/ANSI_escape_code

В идеалния случай трябва да използвате библеотеки като `ansi_term`
при работа със необработени `escape codes`
, за да направите живота ви (и на вашия потребител) по-лесен.

</aside>

## Бележка относно ефективността на изпринтиране

Изпринтирането към терминала е изненадващо бавен!
Ако извикате неща като `println!` в цикъл,
лесно може да се превърне в пречка в иначе бърза програма.
За да ускорите това,
има две неща, които можете да направите.

Първо,
може да искате да намалите броя на изпринтиранията
които всъщност се "заливат" към терминала.
`println!` казва на системата да "залива" терминала _всеки_ път,
тъй като е обичайно да се отпечатва всеки на нов ред.
Ако нямате нужда от това,
можете да увиете своя `stdout` заявка в [`BufWriter`]
който по подразбиране буферира до 8 kB.
(Все още можете да извикате функцията `.flush()` на този `BufWriter`
когато е нужно да изпринтирате незабавно.)

```rust
use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let mut handle = io::BufWriter::new(stdout); // optional: wrap that handle in a buffer
writeln!(handle, "foo: {}", 42); // add `?` if you care about errors here
```

Второ,
помага за придобиване на заключване на `stdout` (или `stderr`)
и използване на функцията `writeln!` за да отпечатате директно.
Това предотвратява заключването и отключването на `stdout` отново и отново.

```rust
use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let mut handle = stdout.lock(); // acquire a lock on it
writeln!(handle, "foo: {}", 42); // add `?` if you care about errors here
```

Можете също така да комбинирате двата подхода.

[`BufWriter`]: https://doc.rust-lang.org/1.39.0/std/io/struct.BufWriter.html

## Показване на лента за напредък

Някои CLI приложения работят по-малко от секунда,
други отнемат минути или часове.
Ако пишете един от последните типове програми,
може да искате да покажете на потребителя, че нещо се случва.
За целта трябва да опитате да отпечатате полезни актуализации на състоянието,
в идеалния случай във форма, която може лесно да се консумира.

Използвайки библеотеката [indicatif],
можете да добавите ленти за напредък
и малки спинери към вашата програма.
Ето един бърз пример:

```rust,ignore
{{#include output-progressbar.rs:1:9}}
```

Посетете [документацията][indicatif docs]
и [примерите][indicatif examples]
за повече информация.

[indicatif]: https://crates.io/crates/indicatif
[indicatif docs]: https://docs.rs/indicatif
[indicatif examples]: https://github.com/mitsuhiko/indicatif/tree/master/examples

## Логване

За да разберем по-лесно какво се случва в нашата програма,
може да искаме да добавим някои регистрационни отчети - логове.
Това обикновено е лесно, докато пишете вашата програма.
Но ще стане супер полезно, когато стартирате тази програма отново след половин година.
В известно отношение,
логването е същото като използването `println!`,
за разлика от това, че можете да посочите важността на съобщението.
Нивата, които обикновено можете да използвате са: _error_, _warn_, _info_, _debug_, и _trace_
(_error_ има най-висок приоритет, _trace_ най-ниската).

За да добавите просто логване към вашето приложение,
ще ви трябват две неща:
Библеотеката [log] (това съдържа макроси, именувани на нивата за логване)
и _адаптер_ което всъщност записва изхода от логовете някъде полезно.
Възможността да използвате адаптери за логване на файлове е много гъвкава:
Можете например да ги използвате за записване на лог файлове не само в терминала
но също и към [syslog] или към централен сървър за логове.

[syslog]: https://en.wikipedia.org/wiki/Syslog

Тъй като в момента се занимаваме само с писането на CLI приложение,
лесен за използване адаптер е [env_logger].
Нарича се "env" логер защото можете да използвате
променлива на средата, за да посочите кои части от вашето приложение
искате да логвате
(и на кое ниво искате да ги логвате).
Той ще префиксира вашите съобщения в логовете с времеви печат
и модула, откъдето идват съобщенията.
Тъй като библиотеките също могат да използват `log`,
вие лесно можете да конфигурирате и изхода им в логовете.

[log]: https://crates.io/crates/log
[env_logger]: https://crates.io/crates/env_logger

Ето един бърз пример:

```rust,ignore
{{#include output-log.rs}}
```

Ако приемем, че имате този файл като `src/bin/output-log.rs`,
в Linux и macOS, можете да го стартирате така:

```console
$ env RUST_LOG=info cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
```

В Windows PowerShell, можете да го стартирате така:

```console
$ $env:RUST_LOG="info"
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
```

В Windows CMD, можете да го стартирате така:

```console
$ set RUST_LOG=info
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
```

`RUST_LOG` е името на променливата в средата, който
можете да използвате, за да зададете настройките на вашите логвания.
`env_logger` съдържа конструктор
така че програмно да коригирате тези настройки
и, например, за показване на съобщения от _info_ ниво по подразбиране.

Има много алтернативни адаптери за логване,
както и алтернативи или разширения на `log`.
Ако знаете, че вашето приложение ще има много за логване,
не забравяйте да ги прегледате,
и улеснете живота на вашите потребители.

<aside>

**Съвет:**
Опитът показва, че дори леко полезните CLI програми могат да се окажат използвани години наред.
(Особено ако са предназначени като временно решение.)
Ако приложението ви не работи
и някой (например вие в бъдеще) трябва да разбере защо,
да сте в състояние да подадете командата `--verbose`, за да получите допълнителен лог изход
може да направи разликата между минути и часове отстраняване на грешки.
Библеотеката [clap-verbosity-flag] съдържа бърз начин
за добавяне на командата `--verbose` на проект ако използва `clap`.

[clap-verbosity-flag]: https://crates.io/crates/clap-verbosity-flag

</aside>
