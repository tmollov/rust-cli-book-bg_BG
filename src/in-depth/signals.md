# Обработка на сигнали

Процеси,
като приложения от командния ред,
трябва да реагира на сигнали, изпратени от операционната система.
Най-често срещаният пример е може би <kbd>Ctrl</kbd>+<kbd>C</kbd>,
сигналът, който обикновено казва на процес да прекрати.
За обработка на сигнали в програми на Rust
трябва да обмислите как можете да получавате тези сигнали
както и как можете да реагирате на тях.

<aside>

**Забележка:**
Ако вашите приложения не се нуждаят от елегантно изключване,
обработката по подразбиране е достатъчна
(т.е. излезте веднага
и оставяте операционната система да почиства ресурсите, като манипулатори за отваряне на файлове и др.).
В този случай:
Няма нужда да правите това, което ви казва тази глава!

Обаче,
за приложения, които трябва да почистват след себе си,
тази глава е много подходяща!
Например,
ако приложението ви трябва
правилно да затвори мрежовите връзки
(казвайки "довиждане" на процесите в другия край),
да премахва временни файлове,
или да нулира системните настройки,
прочетете нататък.

</aside>

## Разлики между операционните системи

В `Unix` системи
(като Linux, macOS, и FreeBSD)
даден процес може да получи [сигнали].
То може или да реагира на тях
по стандартен (осигурен от операционната система) начин,
да хване сигнала и да го обработва по програмно дефиниран начин,
или да игнорира сигнала напълно.

[сигнали]: https://manpages.ubuntu.com/manpages/bionic/en/man7/signal.7.html

`Windows` няма сигнали.
Можеш да използваш [Конзолни манипулатори]
за дефиниране на обратни извиквания, които се изпълняват при възникване на събитие.
Има и [структурирана обработка на грешките]
който обработва всички различни видове системни грешки като делене на нула, грешки за невалиден достъп, препълване на стека и т.н.

[Конзолни манипулатори]: https://docs.microsoft.com/en-us/windows/console/console-control-handlers

## Първо: Обработване на Ctrl+C

Библиотеката [ctrlc] прави точно това, което подсказва името:
Позволява ви да реагирате на сигналите от потребителя с <kbd>Ctrl</kbd>+<kbd>C</kbd>,
по междуплатформен начин.
Основният начин за използване на библиотеката е следният:

[ctrlc]: https://crates.io/crates/ctrlc

```rust,ignore
{{#include signals-ctrlc.rs}}
```

Това, разбира се, не е толкова полезно:
Той само отпечатва съобщение, но иначе не спира програмата.

В програма от реалния свят,
добра идея е вместо това да зададете променлива в манипулатора на сигнали
това и да го проверявате на различни места във вашата програма.
Например,
можете да зададете `Arc<AtomicBool>`
(булева стойност за споделяне между нишки)
във вашия манипулатор на сигнали,
и във важни цикли,
или когато чакате нишка,
периодично да проверите стойността му
и да спрете когато то стане `true`.

## Работа с други видове сигнали

Библиотеката [ctrlc] обработва само комбинацията <kbd>Ctrl</kbd>+<kbd>C</kbd>,
или, как би се наричало в Unix системите `SIGINT` (сигнал за "прекъсване").
За да реагирате на повече Unix сигнали,
трябва да погледнете в [signal-hook].
Дизайнът му е описан в [този блог][signal-hook-post],
и в момента е библиотеката с най-широка обществена подкрепа.

Ето и един прост пример:

```rust,ignore
{{#include signals-hooked.rs}}
```

[signal-hook-post]: https://vorner.github.io/2018/06/28/signal-hook.html

## Използване на канали

Вместо да зададете променлива
и да имате други части на програмата да я проверят,
можете да използвате канали:
Можете да създавате канали, в които манипулаторите на сигнали да излъчват стойности
когато даден сигнал е приет.
В кода на вашето приложение ги използвате
тези и други канали
като точки за синхронизация между нишки.
Използвайки библиотеката [crossbeam-channel] то би изглеждало така:

[crossbeam-channel]: https://crates.io/crates/crossbeam-channel

```rust,ignore
{{#include signals-channels.rs}}
```

## Използване на фючъри и потоци

Ако използвате [tokio],
най-вероятно вече пишете вашето приложение
с асинхронни модели и дизайн, управляван от събития.
Вместо да използвате директно каналите на `crossbeam`,
можете да активирате функцията `tokio-support` на signal-hook.
Това ви позволява да извикате [`.into_async()`]
върху типовете `Signals` от signal-hook
за да получите нов тип, който имплементира `futures::Stream`.

[signal-hook]: https://crates.io/crates/signal-hook
[tokio]: https://tokio.rs/
[`.into_async()`]: https://docs.rs/signal-hook/0.1.6/signal_hook/iterator/struct.Signals.html#method.into_async

## Какво да направите, когато получите друга Ctrl+C докато се справяте с първия Ctrl+C

Повечето потребители ще натиснат <kbd>Ctrl</kbd>+<kbd>C</kbd>,
и след това ще изчакат програмата ви няколко секунди да излезе,
или да им кажете какво става.
Ако това не се случи,
ще натискат <kbd>Ctrl</kbd>+<kbd>C</kbd> отново и отново.
Типичното поведение е приложението да се затвори незабавно.
