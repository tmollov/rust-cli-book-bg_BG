<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Command Line Applications in Rust</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/special-content.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Предговор</a></li><li class="chapter-item expanded "><a href="tutorial/index.html"><strong aria-hidden="true">1.</strong> Приложение за команден ред в рамките на 15 минути</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/setup.html"><strong aria-hidden="true">1.1.</strong> Настройване на проекта</a></li><li class="chapter-item expanded "><a href="tutorial/cli-args.html"><strong aria-hidden="true">1.2.</strong> Анализиране на аргументите подадени на командния ред</a></li><li class="chapter-item expanded "><a href="tutorial/impl-draft.html"><strong aria-hidden="true">1.3.</strong> Първа имплементация</a></li><li class="chapter-item expanded "><a href="tutorial/errors.html"><strong aria-hidden="true">1.4.</strong> По-добро отчитане на грешки</a></li><li class="chapter-item expanded "><a href="tutorial/output.html"><strong aria-hidden="true">1.5.</strong> Изход за хора и машини</a></li><li class="chapter-item expanded "><a href="tutorial/testing.html"><strong aria-hidden="true">1.6.</strong> Тестване</a></li><li class="chapter-item expanded "><a href="tutorial/packaging.html"><strong aria-hidden="true">1.7.</strong> Опаковане и разпространение на Rust инструмент</a></li></ol></li><li class="chapter-item expanded "><a href="in-depth/index.html"><strong aria-hidden="true">2.</strong> Задълбочени теми</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="in-depth/signals.html"><strong aria-hidden="true">2.1.</strong> Обработка на сигнали</a></li><li class="chapter-item expanded "><a href="in-depth/config-files.html"><strong aria-hidden="true">2.2.</strong> Използване на конфигурационни файлове</a></li><li class="chapter-item expanded "><a href="in-depth/exit-code.html"><strong aria-hidden="true">2.3.</strong> Кодове за изход</a></li><li class="chapter-item expanded "><a href="in-depth/human-communication.html"><strong aria-hidden="true">2.4.</strong> Общуване с хора</a></li><li class="chapter-item expanded "><a href="in-depth/machine-communication.html"><strong aria-hidden="true">2.5.</strong> Общуване с машини</a></li><li class="chapter-item expanded "><a href="in-depth/docs.html"><strong aria-hidden="true">2.6.</strong> Рендиране на документация за вашето CLI приложение</a></li></ol></li><li class="chapter-item expanded "><a href="resources/index.html"><strong aria-hidden="true">3.</strong> Ресурси</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Command Line Applications in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-cli/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Приложения-за-команден-ред-в-rust"><a class="header" href="#Приложения-за-команден-ред-в-rust">Приложения за команден ред в Rust</a></h1>
<p>Rust е статично компилиран, бърз език със страхотни инструменти и бързо развиваща се екосистема.
Това го прави много подходящ за писане на приложения за команден ред:
Те трябва да са малки, преносими и бързи при изпълнение.
Приложенията за команден ред също са чудесен начин да започнете да изучавате Rust;
или да представите Rust на вашия екип!</p>
<p>Писане на програма с прост интерфейс на командния ред (CLI)
е страхотно упражнение за начинаещи
който е нов в езика и иска да го усети.
Има обаче много аспекти на тази тема,
които често се разкриват едва по-късно.</p>
<p>Тази книга е структурирана така:
Започваме с бърз урок,
след което ще получите работещ CLI инструмент.
Ще се запознаете с някои от основните концепции на Rust
както и основните аспекти на CLI приложенията.
Следват глави, които навлизат в повече подробности
по някои от тези аспекти.</p>
<p>Едно последно нещо, преди да се потопим направо в CLI приложенията:
Ако намерите грешка в тази книга
или искате да ни помогнете да напишем повече съдържание за него,
можете да намерите неговия източник <a href="https://github.com/rust-cli/book">в хранилището на CLI книги</a>.
Ще се радваме да чуем вашите отзиви!
Благодарим Ви!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Научете-rust-като-напишете-приложение-за-команден-ред-в-рамките-на-15-минути"><a class="header" href="#Научете-rust-като-напишете-приложение-за-команден-ред-в-рамките-на-15-минути">Научете Rust като напишете приложение за команден ред в рамките на 15 минути</a></h1>
<p>Този урок ще ви води през писането на
CLI (интерфейс на командния ред) приложение
с <a href="https://rust-lang.org/">Rust</a>.
Ще ви отнеме около петнадесет минути
за да стигнете до момент, в който имате работеща програма
(около глава 1.3).
След това ще продължим да променяме нашата програма
докато стигнем точка, където можем да публикуваме нашия малък инструмент.</p>
<p>Ще научите всички основни неща за това как да започнете,
и къде да намерите повече информация.
Чувствайте се свободни да пропуснете части, които не са нужни да знаете в момента
или да прескочите която и да е точка.</p>
<aside>
<p><strong>Предпоставки:</strong>
Този урок не замества общото въведение в програмирането,
и очаква да сте запознати с няколко общи понятия.
Трябва да ви е удобно да използвате команден ред/терминал.
Ако вече знаете няколко други езика,
това може да бъде добър първи контакт с Rust.</p>
<p><strong>Получаване на помощ:</strong>
Ако в даден момент се почувствате претоварени или объркани от използваните функции,
разгледайте обширната официална документация, която идва с Rust,
преди всичко книгата,
<code>Езикът за програмиране Rust</code>.
То е налице със инсталацията на Rust чрез командада:
<code>rustup doc</code>,
и е достъпен онлайн на <a href="https://doc.rust-lang.org">doc.rust-lang.org</a>.</p>
<p>Също така сте добре дошли да задавате въпроси –
общността на Rust е известна като приятелска и помагаща.
Разгледайте <a href="https://www.rust-lang.org/community">страницата на общността</a>,
за да видите списък с места, където хората обсъждат Rust.</p>
</aside>
<p>Какъв проект искате да напишете?
Какво ще кажете да започнем с нещо просто:
Нека да напишем малко копие на програмата <code>grep</code>.
Това е инструмент, на който можем да дадем низ и път към файл
и ще отпечата само редовете, които съдържат дадения низ.
Нека да го наречем <code>grrs</code> (произнася се “грас”).</p>
<p>Последно,
искаме да можем да управляваме нашия инструмент по този начин:</p>
<pre><code class="language-console">$ cat test.txt
foo: 10
bar: 20
baz: 30
$ grrs foo test.txt
foo: 10
$ grrs --help
[помощен текст, обясняващ наличните опции]
</code></pre>
<aside class="note">
<p><strong>Забележка:</strong>
Тази книга е написана за <a href="https://doc.rust-lang.org/edition-guide/index.html">Rust 2018</a>.
Примерите за код могат да се използват и на Rust 2015,
но може да се наложи да ги промените малко;
например, добавяне на <code>extern crate foo;</code> призиви.</p>
<p>Уверете се, че използвате версия на Rust - 1.31.0 (или по-нов)
и че имате <code>edition = &quot;2018&quot;</code> настроен
в <code>[package]</code> секцията на вашия <code>Cargo.toml</code> файл.</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Настройване-на-проекта"><a class="header" href="#Настройване-на-проекта">Настройване на проекта</a></h1>
<p>Ако още не сте го направили,
<a href="https://www.rust-lang.org/tools/install">инсталирайте Rust</a> на вашия компютър
(трябва да отнеме само няколко минути).
След това отворете терминалa и отидете до директорията
в който искате да поставите кода на приложението си.</p>
<p>Започнете като изпълнявате командата
<code>cargo new grrs</code>
в директорията, която искате да съхранявате проекта.
Ако погледнете новосъздадената <code>grrs</code> директория,
ще намерите типична настройка за проект на Rust:</p>
<ul>
<li><code>Cargo.toml</code> файл, което съхранява метаданните за нашия проект,
вкл. списък със зависимости/външни библиотеки, които използваме.</li>
<li><code>src/main.rs</code> файл, което е началната точка на нашата програма/библеотека.</li>
</ul>
<p>Ако изпълните командата <code>cargo run</code> в директорията <code>grrs</code>
и получавате “Hello World”, значи всичко е готово.</p>
<h2 id="Как-трябва-да-изглежда"><a class="header" href="#Как-трябва-да-изглежда">Как трябва да изглежда</a></h2>
<pre><code class="language-console">$ cargo new grrs
     Created binary (application) `grrs` package
$ cd grrs/
$ cargo run
   Compiling grrs v0.1.0 (/Users/pascal/code/grrs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.70s
     Running `target/debug/grrs`
Hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Анализиране-на-аргументите-подадени-на-командния-ред"><a class="header" href="#Анализиране-на-аргументите-подадени-на-командния-ред">Анализиране на аргументите подадени на командния ред</a></h1>
<p>Типично извикване на нашия CLI инструмент ще изглежда така:</p>
<pre><code class="language-console">grrs foobar test.txt
</code></pre>
<p>Очакваме нашата програма да разгледа файла <code>test.txt</code>
и отпечатва редовете, които съдържат <code>foobar</code>.
Но как да получим тези две стойности?</p>
<p>Текстът след името на програмата често се нарича
“аргументите на командния ред”,
или “флагове на командния ред”
(особено когато изглеждат така <code>--this</code>).
Вътрешно операционната система обикновено ги представлява
като списък от низове –
грубо казано, те се разделят с интервали.</p>
<p>Има много начини да мислим за тези аргументи,
и как да ги анализираме
в нещо по-лесно за работа.
В същото време ще трябва да кажете на потребителите на вашата програма
какви аргументи трябва да дадат
и в какъв формат и ред се очакват.</p>
<h2 id="Получаване-на-аргументи"><a class="header" href="#Получаване-на-аргументи">Получаване на аргументи</a></h2>
<p>Стандартната библиотека съдържа функцията
<a href="https://doc.rust-lang.org/1.39.0/std/env/fn.args.html"><code>std::env::args()</code></a>, която връща <a href="https://doc.rust-lang.org/1.39.0/std/iter/index.html">итератор</a> на дадените аргументи.
Първият запис (в индекс <code>0</code>) ще бъде името, с което е наречена вашата програма (напр. <code>grrs</code>),
тези, които следват, са написани от потребителя.</p>
<p>Получаването на суровите аргументи по този начин е доста лесно (в <code>src/main.rs</code> файла, след функцията <code>fn main() {</code>):</p>
<pre><code class="language-rust ignore">let pattern = std::env::args().nth(1).expect(&quot;no pattern given&quot;);
let path = std::env::args().nth(2).expect(&quot;no path given&quot;);
</code></pre>
<h2 id="cli-аргументите-като-тип-данни"><a class="header" href="#cli-аргументите-като-тип-данни">CLI аргументите като тип данни</a></h2>
<p>Вместо да мислим за тях като за куп текст,
често си струва да ги мислим като персонализиран тип данни
, които представляват входовете към вашата програма.</p>
<p>Вижте <code>grrs foobar test.txt</code>:
Има два аргумента,
първото е <code>pattern</code> (шаблон от низ, който търсим),
и след това <code>path</code> (път към файл, в който да погледнем).</p>
<p>Какво повече можем да кажем за тях?
Е, като за начало и двете са необходими.
Не сме говорили за никакви стойности по подразбиране,
така че очакваме нашите потребители винаги да предоставят две стойности.
Освен това можем да кажем малко за техните видове:
Шаблонът трябва да е низ,
докато втория аргумент трябва да е пътя до даден файл.</p>
<p>В Rust, обичайно е програмите да се структурират около данните, които обработват, така че този
начин за разглеждане на CLI аргументите пасва много добре. Да започнем с това
(в <code>src/main.rs</code> файл , преди функцията <code>fn main() {</code>):</p>
<pre><code class="language-rust ignore">struct Cli {
    pattern: String,
    path: std::path::PathBuf,
}

</code></pre>
<p>Това определя нова структура (<a href="https://doc.rust-lang.org/1.39.0/book/ch05-00-structs.html"><code>struct</code></a>)
който има две полета за съхраняване на данни: <code>pattern</code>, and <code>path</code>.</p>
<aside>
<p><strong>Забележка:</strong>
<a href="https://doc.rust-lang.org/1.39.0/std/path/struct.PathBuf.html"><code>PathBuf</code></a> е нещо като <a href="https://doc.rust-lang.org/1.39.0/std/string/struct.String.html"><code>String</code></a> но за пътища на файловата система, които работят между различни платформи.</p>
</aside>
<p>Сега все още трябва да получим действителните аргументи, които нашата програма е вкарала в тази форма.
Една от възможностите би била ръчно да анализираме списъка с низове, които получаваме от операционната система
и сами да изградим структурата.
Би изглеждало на нещо подобно:</p>
<pre><code class="language-rust ignore">let pattern = std::env::args().nth(1).expect(&quot;no pattern given&quot;);
let path = std::env::args().nth(2).expect(&quot;no path given&quot;);
let args = Cli {
    pattern: pattern,
    path: std::path::PathBuf::from(path),
};
</code></pre>
<p>Това работи, но не е много удобно.
Как бихте се справили с изискването за поддържане на
<code>--pattern=&quot;foo&quot;</code> или <code>--pattern &quot;foo&quot;</code>?
Как бихте имплементирали <code>--help</code>?</p>
<h2 id="Обработване-на-cli-аргументи-с-clap"><a class="header" href="#Обработване-на-cli-аргументи-с-clap">Обработване на CLI аргументи с Clap</a></h2>
<p>Много по-добър начин е да използвате една от многото налични библиотеки.
Най-популярната библиотека за анализиране на аргументи от командния ред
се нарича <a href="https://docs.rs/clap/"><code>clap</code></a>.
Има цялата функционалност, която бихте очаквали,
включително поддръжка за подкоманди, <a href="https://docs.rs/clap_complete/">shell предложения</a>, и страхотни помощни съобщения.</p>
<p>Нека първо да вмъкваме <code>clap</code> като добавим
<code>clap = { version = &quot;4.0&quot;, features = [&quot;derive&quot;] }</code> към <code>[dependencies]</code> секцията
на нашия <code>Cargo.toml</code> файл.</p>
<p>Сега можем да напишем <code>use clap::Parser;</code> в кода ни,
и да добавим <code>#[derive(Parser)]</code> над <code>struct Cli</code>.
Нека също да напишем някои коментари към документацията по това време.</p>
<p>Ще изглежда така (в <code>src/main.rs</code> файла, преди функцията <code>fn main() {</code>):</p>
<pre><code class="language-rust ignore">use clap::Parser;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(Parser)]
struct Cli {
    /// The pattern to look for
    pattern: String,
    /// The path to the file to read
    path: std::path::PathBuf,
}
</code></pre>
<aside class="node">
<p><strong>Забележка:</strong>
Има много персонализирани атрибути, които можете да добавите към полетата.
Например,
за да кажете, че искате да използвате това поле за аргумента след <code>-o</code> или <code>--output</code>,
трябва да добавите <code>#[arg(short = 'o', long = &quot;output&quot;)]</code>.
За повече информация,
погледнете <a href="https://docs.rs/clap/">документацията за clap</a>.</p>
</aside>
<p>Точно под <code>Cli</code> структурата нашият шаблон съдържа функцията <code>main</code>.
Когато програмата стартира, тя ще извика тази функция.
Първият ред е:</p>
<pre><code class="language-rust ignore">fn main() {
    let args = Cli::parse();
}
</code></pre>
<p>Това ще се опита да анализира и прилага аргументите в структурата <code>Cli</code> .</p>
<p>Но какво ще стане, ако това се провали?
Това е красотата на този подход:
<code>Clap</code> знае кои полета да очаква,
и какъв е очакваният им формат.
Може автоматично да генерира хубав <code>--help</code> съобщение,
както и да даде някои големи грешки,
да ви предложи правилния аргумент, например <code>--output</code> когато сте написали <code>--putput</code>.</p>
<aside class="note">
<p><strong>Забележка:</strong>
Метода <code>parse</code> е предназначен да се използва във функцията <code>main</code>.
Когато се провали,
ще отпечата съобщение за грешка или помощ
и веднага ще излезе от програмата.
Не го използвайте на други места!</p>
</aside>
<h2 id="Обобщение"><a class="header" href="#Обобщение">Обобщение</a></h2>
<p>Вашият код трябва да изглежда така:</p>
<pre><code class="language-rust ignore">#![allow(unused)]

use clap::Parser;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(Parser)]
struct Cli {
    /// The pattern to look for
    pattern: String,
    /// The path to the file to read
    path: std::path::PathBuf,
}

fn main() {
    let args = Cli::parse();
}
</code></pre>
<p>Изпълняването на програмката ни без никакви аргументи трябва да изглежда така:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 10.16s
     Running `target/debug/grrs`
error: The following required arguments were not provided:
    &lt;pattern&gt;
    &lt;path&gt;

USAGE:
    grrs &lt;pattern&gt; &lt;path&gt;

For more information try --help
</code></pre>
<p>Можем да предаваме аргументи, когато използваме <code>cargo run</code> директно и ги напишете след  <code>--</code>:</p>
<pre><code class="language-console">$ cargo run -- some-pattern some-file
    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
     Running `target/debug/grrs some-pattern some-file`
</code></pre>
<p>Както виждате,
програмката не връща нищо.
Което е добре:
Това означава, че няма грешка и програмата ни се изпълни и приключи успешно.</p>
<aside class="exercise">
<p><strong>Упражнение за читателите:</strong>
Накарайте тази програма да извежда своите аргументи!</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Първа-имплементация-на-grrs"><a class="header" href="#Първа-имплементация-на-grrs">Първа имплементация на <em>grrs</em></a></h1>
<p>След последната глава за аргументите на командния ред,
имаме входящите данни,
и можем да започнем да пишем нашия действителен инструмент.
Функцията ни <code>main</code> съдържа само този ред в момента:</p>
<pre><code class="language-rust ignore">    let args = Cli::parse();
</code></pre>
<p>Нека започнем, като отворим файла, който имаме.</p>
<pre><code class="language-rust ignore">    let content = std::fs::read_to_string(&amp;args.path).expect(&quot;could not read file&quot;);
</code></pre>
<aside>
<p><strong>Забележка:</strong>
Виждате метода <a href="https://doc.rust-lang.org/1.39.0/std/result/enum.Result.html#method.expect"><code>.expect</code></a> нали?
Това е функция за бърз достъп за излизане, която ще накара програмата да излезе незабавно
когато стойността (в този случай входният файл)
не може да се прочете.
Не е много красиво,
и в следващата глава за <a href="tutorial/./errors.html">По-добро отчитане на грешки</a>
ще разгледаме как да подобрим това.</p>
</aside>
<p>Сега, нека да итерираме редовете
и отпечатаме всеки, който съдържа нашия шаблон:</p>
<pre><code class="language-rust ignore">    for line in content.lines() {
        if line.contains(&amp;args.pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
</code></pre>
<h2 id="Обобщение-1"><a class="header" href="#Обобщение-1">Обобщение</a></h2>
<p>Вашият код сега трябва да изглежда така:</p>
<pre><code class="language-rust ignore">#![allow(unused)]

use clap::Parser;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(Parser)]
struct Cli {
    /// The pattern to look for
    pattern: String,
    /// The path to the file to read
    path: std::path::PathBuf,
}

fn main() {
    let args = Cli::parse();
    let content = std::fs::read_to_string(&amp;args.path).expect(&quot;could not read file&quot;);

    for line in content.lines() {
        if line.contains(&amp;args.pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
}
</code></pre>
<p>Изпробвайте го: <code>cargo run -- main src/main.rs</code> трябва да работи сега!</p>
<aside class="exercise">
<p><strong>Упражнение за читателя:</strong>
Това не е най-добрата имплементация:
Той ще прочете целия файл в паметта
– колкото и голям да е файлът.
Намерете начин да го оптимизирате!
(Една идея, можете да използвате <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufReader.html"><code>BufReader</code></a>
вместо <code>read_to_string()</code>.)</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="По-добро-отчитане-на-грешки"><a class="header" href="#По-добро-отчитане-на-грешки">По-добро отчитане на грешки</a></h1>
<p>Всички ние не можем да направим нищо, освен да приемем факта, че ще се появят грешки.
И за разлика от много други езици,
много е трудно да не забележиш и да не се справиш с тази реалност
когато използваш Rust:
Тъй като няма изключения,
всички възможни състояния на грешките често са кодирани в типа, което функцията връща.</p>
<h2 id="Типът-result"><a class="header" href="#Типът-result">Типът Result</a></h2>
<p>Функция като <a href="https://doc.rust-lang.org/1.39.0/std/fs/fn.read_to_string.html"><code>read_to_string</code></a> не връща низ.
Вместо това то връща <a href="https://doc.rust-lang.org/1.39.0/std/result/index.html"><code>Result</code></a>
, което съдържа или <code>String</code>
, или грешка от някакъв вид
(в този случай <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>std::io::Error</code></a>).</p>
<p>Как разбираме кое е от двете?
Тъй като <code>Result</code> е от тип <code>enum</code>,
може да използваме <code>match</code>, за да проверите кой от двете варианта е:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::fs::read_to_string(&quot;test.txt&quot;);
match result {
    Ok(content) =&gt; { println!(&quot;File content: {}&quot;, content); }
    Err(error) =&gt; { println!(&quot;Oh noes: {}&quot;, error); }
}
<span class="boring">}
</span></code></pre></pre>
<aside>
<p><strong>Забележка:</strong>
Не сте сигурен какво представляват <code>enum</code> и как работят в Rust?
<a href="https://doc.rust-lang.org/1.39.0/book/ch06-00-enums.html">Вижте тази глава от книгата за Rust</a>
, за да сте в крак с този наръчник.</p>
</aside>
<h2 id="Разопаковане---unwrapping"><a class="header" href="#Разопаковане---unwrapping">Разопаковане - Unwrapping</a></h2>
<p>Сега успяхме да получим достъп до съдържанието на файла,
но всъщност не можем да направим нищо с него след <code>match</code> блока.
За това ще трябва по някакъв начин да се справим при случай на грешка.
Предизвикателството е, че всички потоци на изпълнението на блока <code>match</code> трябва да връщат нещо от същия тип.
Но има хитър трик, за да го заобиколите:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::fs::read_to_string(&quot;test.txt&quot;);
let content = match result {
    Ok(content) =&gt; { content },
    Err(error) =&gt; { panic!(&quot;Can't deal with {}, just exit here&quot;, error); }
};
println!(&quot;file content: {}&quot;, content);
<span class="boring">}
</span></code></pre></pre>
<p>Може да използвате <code>String</code>-а от <code>content</code> след <code>match</code> блока.
Ако <code>result</code> дава грешка, <code>String</code> няма да съществува.
Но тъй като програмата щеше да излезе, преди да достигне тази точката, в която използваме <code>content</code>,
това е възможно.</p>
<p>Това може да изглежда драстично,
но е много удобно.
Ако вашата програма трябва да прочете този файл и не може да направи нищо, ако файлът не съществува,
излизането е валидна стратегия.
Има дори включен метод за бърз достъп на <code>Result</code>-та, която се нарича <code>unwrap</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let content = std::fs::read_to_string(&quot;test.txt&quot;).unwrap();
<span class="boring">}
</span></code></pre></pre>
<h2 id="Няма-нужда-от-panic"><a class="header" href="#Няма-нужда-от-panic">Няма нужда от <code>panic</code></a></h2>
<p>Разбира се, прекъсването на програмата не е единственият начин за справяне с грешките.
Вместо  <code>panic!</code>, ние също можем лесно да напишем <code>return</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span>let result = std::fs::read_to_string(&quot;test.txt&quot;);
let content = match result {
    Ok(content) =&gt; { content },
    Err(error) =&gt; { return Err(error.into()); }
};
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>Това обаче променя типа, която се връща, от който се нуждае нашата функция.
Наистина имаше нещо скрито в нашите примери през цялото това време:
Сигнатурата на функцията, в която живее този код.
И в този последен пример с <code>return</code>,
тo става важно.
Ето и <em>целият</em> пример:</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let result = std::fs::read_to_string(&quot;test.txt&quot;);
    let content = match result {
        Ok(content) =&gt; { content },
        Err(error) =&gt; { return Err(error.into()); }
    };
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre></pre>
<p>Нашият тип, който връщаме е <code>Result</code>!
Ето защо можем да пишем <code>return Err(error);</code> във вторя поток на <code>match</code>.
Вижте как има <code>Ok(())</code> най-отдолу?
Това е върнатата стойност по подразбиране на функцията и означава че
“Result е правилно, и няма съдържание”.</p>
<aside>
<p><strong>Забележка:</strong>
Защо това не е написано като <code>return Ok(());</code>?
Лесно може да бъде – това също е напълно валидно.
Последният израз на всеки блок в Rust е стойността, която връща,
и е обичайно да се пропуска ненужния <code>return</code>.</p>
</aside>
<h2 id="Въпросителен-знак"><a class="header" href="#Въпросителен-знак">Въпросителен знак</a></h2>
<p>Също като извикването на функцията <code>.unwrap()</code> е пряк път
за <code>match</code> с <code>panic!</code> в потока за грешки,
имаме друг пряк път за <code>match</code>, което връща стойността <code>return</code> на потока за грешки:
<code>?</code>.</p>
<p>Точно така - въпросителния знак.
Можете да добавите този оператор към стойност на типа <code>Result</code>,
и Rust вътрешно ще разшири това до нещо много подобно на
<code>match</code> блока, което написахме.</p>
<p>Опитайте го:</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let content = std::fs::read_to_string(&quot;test.txt&quot;)?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre></pre>
<p>Много е сбито!</p>
<aside>
<p><strong>Забележка:</strong>
Тук се случват още няколко неща
, което не е нужно да разбирате, за да работите с тях.
Например,
типа грешка в нашия <code>main</code> функция е <code>Box&lt;dyn std::error::Error&gt;</code>.
Но ние видяхме по-горе това <code>read_to_string</code>, че връща <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>std::io::Error</code></a>.
Това работи, защото <code>?</code> се разширява до код, което  <em>превръща</em> типовете грешки.</p>
<p><code>Box&lt;dyn std::error::Error&gt;</code> също е интересен тип.
Това е контейнер - <code>Box</code>, което може да съдържа <em>всякакъв</em> тип
който прилага стандартния тип <a href="https://doc.rust-lang.org/1.39.0/std/error/trait.Error.html"><code>Error trait</code></a>.
Това означава, че по принцип всички грешки могат да бъдат поставени в това поле,
така че можем да използваме <code>?</code> на всички обичайни функции, които връщат <code>Result</code> типа.</p>
</aside>
<h2 id="Осигуряване-на-контекст"><a class="header" href="#Осигуряване-на-контекст">Осигуряване на контекст</a></h2>
<p>Грешките, които получавате, когато използвате <code>?</code> във вашата <code>main</code> функция, са наред,
но не са страхотни.
Например:
Когато изпълним <code>std::fs::read_to_string(&quot;test.txt&quot;)?</code>
но файла <code>test.txt</code> не съществува,
получавате този резултат:</p>
<pre><code class="language-text">Error: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
</code></pre>
<p>В случаите, когато вашият код не съдържа буквално името на файла,
би било много трудно да се каже кой файл не е намерен.
Има много начини да се справите с това.</p>
<p>Например, можем да създадем наш собствен тип грешка,
и след това да използваме това, за да създадем персонализирано съобщение за грешка:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
struct CustomError(String);

fn main() -&gt; Result&lt;(), CustomError&gt; {
    let path = &quot;test.txt&quot;;
    let content = std::fs::read_to_string(path)
        .map_err(|err| CustomError(format!(&quot;Error reading `{}`: {}&quot;, path, err)))?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre>
<p>Сега,
изпълнявайки това, ще получим нашето персонализирано съобщение за грешка:</p>
<pre><code class="language-text">Error: CustomError(&quot;Error reading `test.txt`: No such file or directory (os error 2)&quot;)
</code></pre>
<p>Не е много приятно,
но можем лесно да адаптираме изхода за отстраняване на грешки за нашия тип по-късно.</p>
<p>Този шаблон всъщност е срещан доста често.
Обаче има един проблем:
Ние не съхраняваме оригиналната грешка,
само неговото низово представяне.
Често използваната <a href="https://docs.rs/anyhow"><code>anyhow</code></a> библеотека има чудесно решение за този проблем:
подобно на нашия <code>CustomError</code> тип,
неговия <a href="https://docs.rs/anyhow/1.0/anyhow/trait.Context.html"><code>Context trait</code></a> може да се използва за добавяне на описание.
Освен това запазва и оригиналната грешка,
така че получаваме “верига” от съобщения за грешката, посочващи коренната причина.</p>
<p>Нека да вмъкнем <code>anyhow</code> библеотеката като добавим
<code>anyhow = &quot;1.0&quot;</code> в <code>[dependencies]</code> секцията
в файла <code>Cargo.toml</code>.</p>
<p>Тогава пълният пример би изглеждало така:</p>
<pre><code class="language-rust ignore">use anyhow::{Context, Result};

fn main() -&gt; Result&lt;()&gt; {
    let path = &quot;test.txt&quot;;
    let content = std::fs::read_to_string(path)
        .with_context(|| format!(&quot;could not read file `{}`&quot;, path))?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre>
<p>Това ще отпечата грешката:</p>
<pre><code class="language-text">Error: could not read file `test.txt`

Caused by:
    No such file or directory (os error 2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Изход"><a class="header" href="#Изход">Изход</a></h1>
<h2 id="Принтиране-на-hello-world"><a class="header" href="#Принтиране-на-hello-world">Принтиране на “Hello World”</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello World&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Е, това беше лесно.
Страхотно, към следващата тема.</p>
<h2 id="Използване-на-println"><a class="header" href="#Използване-на-println">Използване на <code>println!</code></a></h2>
<p>Можете почти да отпечатате всички неща, който харесвате
с т.нар. макро (macro ) функция - <code>println!</code>.
Макросите имат някои доста невероятни възможности,
но и специален синтаксис.
Той очаква да напишете низов литерал като първи параметър,
който съдържа контейнери, които ще бъдат попълнени
по стойностите на параметрите, които следват като допълнителни аргументи.</p>
<p>Например:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
println!(&quot;My lucky number is {}.&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>ще изпринтира</p>
<pre><code class="language-console">My lucky number is 42.
</code></pre>
<p>Къдравите скоби (<code>{}</code>) в горния низ е един от тези контейнери.
Това е типът заместител по подразбиране
който се опитва да отпечата дадената стойност по разбираем за човека начин.
За числа и низове това работи много добре,
но не всички видове могат да направят това.
Ето защо има и “репрезентиране при дебъгване”,
който можете да получите, като попълните скобите на контейнера по следния начин: <code>{:?}</code>.</p>
<p>Например,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xs = vec![1, 2, 3];
println!(&quot;The list is: {:?}&quot;, xs);
<span class="boring">}
</span></code></pre></pre>
<p>Ще изпринтира:</p>
<pre><code class="language-console">The list is: [1, 2, 3]
</code></pre>
<p>Ако искате вашите собствени типове данни да могат да се отпечатват за дебъгване и логване,
в повечето случаи можете да добавите <code>#[derive(Debug)]</code> над тяхната дефиниция.</p>
<aside>
<p><strong>Забележка:</strong>
“Потребителско-приятно” изпринтиране се извършва с помощта на [<code>Display trait</code>],
изпринтирането при дебъгване (четими за хора, но насочени към разработчиците) използва [<code>Debug trait</code>].
Можете да намерите повече информация за синтаксиса, в който можете да използвате в <code>println!</code>
в <a href="https://doc.rust-lang.org/1.39.0/std/fmt/index.html">документацията за модула <code>std::fmt</code></a>.</p>
</aside>
<h2 id="Изпринтиране-на-грешки"><a class="header" href="#Изпринтиране-на-грешки">Изпринтиране на грешки</a></h2>
<p>Изпринтиране на грешки трябва да се правят чрез <code>stderr</code>
за да улеснят потребителите
и другите инструменти
за препращане на техните изходи към файлове
или повече инструменти.</p>
<aside>
<p><strong>Забележка:</strong>
В повечето операционни системи,
една програма може да пише в два изходни потока, <code>stdout</code> и <code>stderr</code>.
<code>stdout</code> е за действителния изход на програмата,
докато <code>stderr</code> позволява грешките и другите съобщения да се съхраняват отделно от <code>stdout</code>.
По този начин,
изходът може да бъде съхранен във файл или прехвърлен към друга програма
докато грешките се показват на потребителя.</p>
</aside>
<p>В Rust това се постига
с <code>println!</code> и <code>eprintln!</code>,
като първия използва <code>stdout</code> за изход,
а последния <code>stderr</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;This is information&quot;);
eprintln!(&quot;This is an error! :(&quot;);
<span class="boring">}
</span></code></pre></pre>
<aside>
<p><strong>Внимавайте</strong>: Изпринтирането на т.нар. <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">escape codes</a> може да е опасно,
поставяйки терминала на потребителя в странно състояние.
Винаги внимавайте, когато ги отпечатвате ръчно!</p>
<p>В идеалния случай трябва да използвате библеотеки като <code>ansi_term</code>
при работа със необработени <code>escape codes</code>
, за да направите живота ви (и на вашия потребител) по-лесен.</p>
</aside>
<h2 id="Бележка-относно-ефективността-на-изпринтиране"><a class="header" href="#Бележка-относно-ефективността-на-изпринтиране">Бележка относно ефективността на изпринтиране</a></h2>
<p>Изпринтирането към терминала е изненадващо бавен!
Ако извикате неща като <code>println!</code> в цикъл,
лесно може да се превърне в пречка в иначе бърза програма.
За да ускорите това,
има две неща, които можете да направите.</p>
<p>Първо,
може да искате да намалите броя на изпринтиранията
които всъщност се “заливат” към терминала.
<code>println!</code> казва на системата да “залива” терминала <em>всеки</em> път,
тъй като е обичайно да се отпечатва всеки на нов ред.
Ако нямате нужда от това,
можете да увиете своя <code>stdout</code> заявка в <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufWriter.html"><code>BufWriter</code></a>
който по подразбиране буферира до 8 kB.
(Все още можете да извикате функцията <code>.flush()</code> на този <code>BufWriter</code>
когато е нужно да изпринтирате незабавно.)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let mut handle = io::BufWriter::new(stdout); // optional: wrap that handle in a buffer
writeln!(handle, &quot;foo: {}&quot;, 42); // add `?` if you care about errors here
<span class="boring">}
</span></code></pre></pre>
<p>Второ,
помага за придобиване на заключване на <code>stdout</code> (или <code>stderr</code>)
и използване на функцията <code>writeln!</code> за да отпечатате директно.
Това предотвратява заключването и отключването на <code>stdout</code> отново и отново.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let mut handle = stdout.lock(); // acquire a lock on it
writeln!(handle, &quot;foo: {}&quot;, 42); // add `?` if you care about errors here
<span class="boring">}
</span></code></pre></pre>
<p>Можете също така да комбинирате двата подхода.</p>
<h2 id="Показване-на-лента-за-напредък"><a class="header" href="#Показване-на-лента-за-напредък">Показване на лента за напредък</a></h2>
<p>Някои CLI приложения работят по-малко от секунда,
други отнемат минути или часове.
Ако пишете един от последните типове програми,
може да искате да покажете на потребителя, че нещо се случва.
За целта трябва да опитате да отпечатате полезни актуализации на състоянието,
в идеалния случай във форма, която може лесно да се консумира.</p>
<p>Използвайки библеотеката <a href="https://crates.io/crates/indicatif">indicatif</a>,
можете да добавите ленти за напредък
и малки спинери към вашата програма.
Ето един бърз пример:</p>
<pre><code class="language-rust ignore">fn main() {
    let pb = indicatif::ProgressBar::new(100);
    for i in 0..100 {
        do_hard_work();
        pb.println(format!(&quot;[+] finished #{}&quot;, i));
        pb.inc(1);
    }
    pb.finish_with_message(&quot;done&quot;);
}
</code></pre>
<p>Посетете <a href="https://docs.rs/indicatif">документацията</a>
и <a href="https://github.com/console-rs/indicatif/tree/main/examples">примерите</a>
за повече информация.</p>
<h2 id="Логване"><a class="header" href="#Логване">Логване</a></h2>
<p>За да разберем по-лесно какво се случва в нашата програма,
може да искаме да добавим някои регистрационни отчети - логове.
Това обикновено е лесно, докато пишете вашата програма.
Но ще стане супер полезно, когато стартирате тази програма отново след половин година.
В известно отношение,
логването е същото като използването <code>println!</code>,
за разлика от това, че можете да посочите важността на съобщението.
Нивата, които обикновено можете да използвате са: <em>error</em>, <em>warn</em>, <em>info</em>, <em>debug</em>, и <em>trace</em>
(<em>error</em> има най-висок приоритет, <em>trace</em> най-ниската).</p>
<p>За да добавите просто логване към вашето приложение,
ще ви трябват две неща:
Библеотеката <a href="https://crates.io/crates/log">log</a> (това съдържа макроси, именувани на нивата за логване)
и <em>адаптер</em> което всъщност записва изхода от логовете някъде полезно.
Възможността да използвате адаптери за логване на файлове е много гъвкава:
Можете например да ги използвате за записване на лог файлове не само в терминала
но също и към <a href="https://en.wikipedia.org/wiki/Syslog">syslog</a> или към централен сървър за логове.</p>
<p>Тъй като в момента се занимаваме само с писането на CLI приложение,
лесен за използване адаптер е <a href="https://crates.io/crates/env_logger">env_logger</a>.
Нарича се “env” логер защото можете да използвате
променлива на средата, за да посочите кои части от вашето приложение
искате да логвате
(и на кое ниво искате да ги логвате).
Той ще префиксира вашите съобщения в логовете с времеви печат
и модула, откъдето идват съобщенията.
Тъй като библиотеките също могат да използват <code>log</code>,
вие лесно можете да конфигурирате и изхода им в логовете.</p>
<p>Ето един бърз пример:</p>
<pre><code class="language-rust ignore">use log::{info, warn};

fn main() {
    env_logger::init();
    info!(&quot;starting up&quot;);
    warn!(&quot;oops, nothing implemented!&quot;);
}
</code></pre>
<p>Ако приемем, че имате този файл като <code>src/bin/output-log.rs</code>,
в Linux и macOS, можете да го стартирате така:</p>
<pre><code class="language-console">$ env RUST_LOG=info cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>В Windows PowerShell, можете да го стартирате така:</p>
<pre><code class="language-console">$ $env:RUST_LOG=&quot;info&quot;
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>В Windows CMD, можете да го стартирате така:</p>
<pre><code class="language-console">$ set RUST_LOG=info
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p><code>RUST_LOG</code> е името на променливата в средата, който
можете да използвате, за да зададете настройките на вашите логвания.
<code>env_logger</code> съдържа конструктор
така че програмно да коригирате тези настройки
и, например, за показване на съобщения от <em>info</em> ниво по подразбиране.</p>
<p>Има много алтернативни адаптери за логване,
както и алтернативи или разширения на <code>log</code>.
Ако знаете, че вашето приложение ще има много за логване,
не забравяйте да ги прегледате,
и улеснете живота на вашите потребители.</p>
<aside>
<p><strong>Съвет:</strong>
Опитът показва, че дори леко полезните CLI програми могат да се окажат използвани години наред.
(Особено ако са предназначени като временно решение.)
Ако приложението ви не работи
и някой (например вие в бъдеще) трябва да разбере защо,
да сте в състояние да подадете командата <code>--verbose</code>, за да получите допълнителен лог изход
може да направи разликата между минути и часове отстраняване на грешки.
Библеотеката <a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a> съдържа бърз начин
за добавяне на командата <code>--verbose</code> на проект ако използва <code>clap</code>.</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Тестване"><a class="header" href="#Тестване">Тестване</a></h1>
<p>В продължение на десетилетия разработка на софтуер,
хората са открили една истина:
Нетестваният софтуер рядко работи.
(Много хора биха стигнали дотам, че да кажат:
„Повечето тестван софтуер също не работи.“
Но тук всички сме оптимисти, нали?)
Така че, за да сте сигурни, че вашата програма прави това, което очаквате да прави,
разумно е да го тествате.</p>
<p>Един лесен начин да направите това е
да напишете <code>README</code> файл
който описва какво трябва да прави вашата програма.
И когато се почувствате готови да направите ново издание,
преминете през <code>README</code> файла и гарантирайте това
поведението все още е според очакванията.
Можете да направите това по-строго упражнение
като също така запишете как вашата програма трябва да реагира на грешни входове.</p>
<p>Ето още една интересна идея:
Напишете <code>README</code> файла преди да напишете кода.</p>
<aside>
<p><strong>Забележка:</strong>
Погледнете на
<a href="https://dev.bg/digest/test-driven-development/">Test-Driver Development</a> (TDD)
ако не сте чували за него.</p>
</aside>
<h2 id="Автоматизирано-тестване"><a class="header" href="#Автоматизирано-тестване">Автоматизирано тестване</a></h2>
<p>Сега, всичко това е чудесно,
но да направите всичко това ръчно?
Това може да отнеме много време.
По същото време,
много хора започнаха да изпитват удоволствие да казват на компютрите да правят неща вместо тях.
Нека поговорим как да автоматизираме тези тестове.</p>
<p>Rust има вградена тестов <code>framework</code>
така че нека започнем с написването на първия ни тест:</p>
<pre><code class="language-rust ignore"><span class="boring">fn answer() -&gt; i32 {
</span><span class="boring">  42
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn check_answer_validity() {
    assert_eq!(answer(), 42);
}
</code></pre>
<p>Можете да поставите този кодов фрагмент в почти всеки файл
и <code>cargo test</code> ще намери
и ще го изпълни.
Ключът тук е <code>#[test]</code> атрибутът.
Това позволява на системата за изграждане да открие такива функции
и да ги изпълни като тестове,
проверявайки дали са коректни.</p>
<aside class="exercise">
<p><strong>Упражнение за читателя:</strong>
Накарайте този тест да проработи.</p>
<p>Трябва да получите резултат като следния:</p>
<pre><code class="language-text">running 1 test
test check_answer_validity ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
</aside>
<p>Сега, след като видяхме <em>как</em> можем да пишем тестове,
все още трябва да разберем <em>какво</em> да тестваме.
Както видяхте, е доста лесно да се пишат твърдения
за функции.
Но едно CLI приложение често има повече от една функция!
По-лошото е, че то често се занимава с входните данни от потребителя,
четене от файлове
и изваждане на резултат.</p>
<h2 id="Направете-кода-си-годен-за-тестване"><a class="header" href="#Направете-кода-си-годен-за-тестване">Направете кода си годен за тестване</a></h2>
<p>Има два допълващи се подхода за тестване на функционалността:
Тестване малки единици, от които изграждате цялото си приложение,
които се наричат “unit tests”.
И също така и тестване на готовото приложение “от външната страна”
наречено още “black box tests” или “integration tests” (интеграционни тестове).
Нека да започнем с първия.</p>
<p>За да разберем какво трябва да тестваме,
нека да видим какви са функциите на нашата програма.
Главно, <code>grrs</code> трябва да отпечата редовете, които отговарят на даден шаблон.
И така, нека да напишем <code>unit</code> тестове <em>точно за това</em>:
Искаме да сме сигурни, че нашата най-важна част от логиката работи
и искаме да го направим по начин, който е независим
от всеки код за настройка, който имаме около него
(който се занимава с CLI аргументи, например).</p>
<p>Връщайки се към нашата <a href="tutorial/impl-draft.html">първа имплементация</a> на <code>grrs</code>,
добавихме този блок код към функцията <code>main</code>:</p>
<pre><code class="language-rust ignore">// ...
for line in content.lines() {
    if line.contains(&amp;args.pattern) {
        println!(&quot;{}&quot;, line);
    }
}
</code></pre>
<p>За съжаление, това не е много лесно за тестване.
Първо, това е в основната функция, така че не можем лесно да го извикаме.
Това лесно се коригира чрез преместване на тази част от кода във функция:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_matches(content: &amp;str, pattern: &amp;str) {
    for line in content.lines() {
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Сега можем да извикаме тази функция в нашия тест,
и да видим какъв е изходът му:</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    find_matches(&quot;lorem ipsum\ndolor sit amet&quot;, &quot;lorem&quot;);
    assert_eq!( // uhhhh
</code></pre>
<p>Или… можем ли?
В момента, <code>find_matches</code> отпечатва директно към <code>stdout</code>, т.е. в терминала.
Не можем лесно да уловим това в тест!
Това е проблем, който често се появява
когато пишете тестове след имплементацията на логиката:
Написахме функция, която е здраво интегрирана
в контекста, в който се използва.</p>
<aside class="note">
<p><strong>Забележка:</strong>
Това е напълно правилно, когато пишете малки CLI приложения.
Няма нужда всичко да е тестваем!
Важно е да се мисли за
кои части от кода си обаче бихте искали да напишете <code>unit</code> тестове.
Въпреки че ще видим, че е лесно да промените тази функция, за да бъде тествана,
това не винаги ще е случая.</p>
</aside>
<p>Добре, как можем да направим това тестваем?
Ще трябва някак да уловим резултата.
Стандартната библеотека на Rust има някои чисти абстракции
за работа с I/O (вход/изход)
и ние ще използваме един наречен <a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html"><code>std::io::Write</code></a>.
Това е <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">trait</a> абстрахираща над нещата, за които можем да пишем,
което включва низове, но също така <code>stdout</code>.</p>
<p>Ако за първи път чувате думичката “trait”
в контекста на Rust,
трябва се обогатите.
<code>Trait</code>-овете са са една от най-мощните характеристики на Rust.
Можете да мислите за тях като за интерфейсите в Java,
или типа ‘classes’ в езика Haskell
(с каквото сте по-запознати).
Те ви позволяват да се абстрахирате от поведението
които могат да се споделят от различни типове.
Кодът, който използва <code>trait</code>, могат да
изразяват идеите си по много общи и гъвкави начини.
Това обаче означава, че може да стане трудно за четене.
Не позволявайте на това да ви плаши:
Дори хора, които са използвали Rust от години
не разбират веднага какво прави генеричния код.
А в този случай,
помага да се мисли за конкретни употреби.
Например,
в нашия случай,
поведението, което абстрахираме, е “пиши му / записване”.
Примери за типовете, които го имплементират (“impl”)
са :
Стандартния изход на терминала,
файлове,
буфера в паметта,
или интернет връзка чрез протокола <code>TCP</code>.
(Скролнете надолу в <a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html">документацията за <code>std::io::Write</code></a>
за да видите списък с “Имплементаторите”.)</p>
<p>С това знание,
нека променим нашата функция, за да приеме трети параметър.
Трябва да е от всякакъв тип, който изпълнява <code>Write</code>.
По този начин,
можем да предоставим прост низ
в нашите тестове
и да направим твърдения по него.
Ето как можем да напишем тази версия на функцията <code>find_matches</code>:</p>
<pre><code class="language-rust ignore">fn find_matches(content: &amp;str, pattern: &amp;str, mut writer: impl std::io::Write) {
    for line in content.lines() {
        if line.contains(pattern) {
            writeln!(writer, &quot;{}&quot;, line);
        }
    }
}
</code></pre>
<p>Новия параметър е <code>mut writer</code>,
т.е., променливо, което наричаме “writer”.
Типът му е <code>impl std::io::Write</code>,
което можете да прочетете като
“контейнер за всеки тип, който имплементира <code>Write trait</code>”.
Също така обърнете внимание как
заменихме <code>println!(…)</code>
, което използвахме по-рано
с <code>writeln!(writer, …)</code>.
<code>println!</code> работи по същия начин като <code>writeln!</code>
но винаги използва стандартния изход.</p>
<p>Сега можем да тестваме изхода:</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    let mut result = Vec::new();
    find_matches(&quot;lorem ipsum\ndolor sit amet&quot;, &quot;lorem&quot;, &amp;mut result);
    assert_eq!(result, b&quot;lorem ipsum\n&quot;);
}
</code></pre>
<p>За да използваме това в кода на нашето приложение,
трябва да променим извикването на <code>find_matches</code> в функцията <code>main</code>
като добавим <a href="https://doc.rust-lang.org/1.39.0/std/io/fn.stdout.html"><code>&amp;mut std::io::stdout()</code></a> като трети параметър.
Ето и пример с основната функция
който се основава на това, което видяхме в предишните глави
и използва нашата извлечена функция <code>find_matches</code>:</p>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;()&gt; {
    let args = Cli::parse();
    let content = std::fs::read_to_string(&amp;args.path)
        .with_context(|| format!(&quot;could not read file `{}`&quot;, args.path.display()))?;

    find_matches(&amp;content, &amp;args.pattern, &amp;mut std::io::stdout());

    Ok(())
}
</code></pre>
<aside class="note">
<p><strong>Забележка:</strong>
Тъй като <code>stdout</code> очаква байтове,
използваме <code>std::io::Write</code> вместо <code>std::fmt::Write</code>.
Като резултат,
даваме празен вектор(лист) за “записване на резултатите” в нашия тест
(неговият тип ще бъде <code>Vec&lt;u8&gt;</code>),
в <code>assert_eq!</code> използваме <code>b&quot;foo&quot;</code>.
(Префикса <code>b</code> го превръща в <em>байтов низов литерал</em>
така че неговият тип ще бъде <code>&amp;[u8]</code> вместо <code>&amp;str</code>).</p>
</aside>
<aside class="note">
<p><strong>Забележка:</strong>
Можем също да накараме тази функция да връща <code>String</code>,
но това би променило поведението му.
Вместо да изпринтира директно на терминала,
това ще събере всичко в низ,
и ще извади целия резултат наведнъж в края.</p>
</aside>
<aside class="exercise">
<p><strong>Упражнение за читателя:</strong>
<a href="https://doc.rust-lang.org/1.39.0/std/macro.writeln.html"><code>writeln!</code></a> връща <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>io::Result</code></a>
защото писането може да се провали,
например когато буферът е пълен и не може да бъде разширен.
Добавяне на обработка на грешки към функцията <code>find_matches</code>.</p>
</aside>
<p>Току-що видяхме как да направим тази част от кода лесна за тестване.
Имаме</p>
<ol>
<li>идентифицирахме една от основните части на нашето приложение,</li>
<li>поставихме го в неговата собствена функция,</li>
<li>и го направихме по-гъвкав.</li>
</ol>
<p>Въпреки че целта беше да го направим тестван,
резултатът, до който стигнахме
всъщност е много идиоматично и многократно използвано парче от Rust кода.
Това е страхотно!</p>
<h2 id="Разделяне-на-вашия-код-на-библиотечни-и-изпълняеми-цели"><a class="header" href="#Разделяне-на-вашия-код-на-библиотечни-и-изпълняеми-цели">Разделяне на вашия код на библиотечни и изпълняеми цели</a></h2>
<p>Тук можем да направим още нещо.
Досега сме поставили всичко, което сме написали в файла <code>src/main.rs</code>.
Това означава, че текущият ни проект произвежда един изпълняем файл.
Но можем също да направим нашия код достъпен като библиотека, като:</p>
<ol>
<li>Поставяме функцията <code>find_matches</code> в нов <code>src/lib.rs</code> файл.</li>
<li>Добавяме<code>pub</code> в началото на <code>fn</code> (така че да изглежда така <code>pub fn find_matches</code>)
за да стане нещо, до което потребителите на нашата библиотека да имат достъп.</li>
<li>Премахваме <code>find_matches</code> от файла <code>src/main.rs</code>.</li>
<li>И в <code>fn main</code> функцията, добавяме повикването към <code>find_matches</code> с <code>grrs::</code>,
така че сега да изглежда по този начин: <code>grrs::find_matches(…)</code>.
това означава, че използваме функцията от библиотеката, която току-що написахме!</li>
</ol>
<p>Начинът, по който Rust се справя с проекти, е доста гъвкав
и е добра идея да помислите
какво да поставите като библеотеката в проекта си още от началото.
Можете, например, да помислите за писане на библиотека
първо за специфична за вашето приложението логика
и след това да го използвате във вашия CLI приложение точно като всяка друга библиотека.
Или, ако вашият проект има множество изпълняеми файлове,
можете да поставите общата функционалност в отделна с библиотечка за проекта.</p>
<aside class="note">
<p><strong>Забележка:</strong>
Говорейки за поставяне на всичко в файла <code>src/main.rs</code>:
Ако продължим да правим това,
ще стане трудно за четене.
<a href="https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Модулната система</a> може да ви помогне да структурирате и организирате кода си.</p>
</aside>
<h2 id="Тестване-на-cli-приложения-чрез-стартирането-им"><a class="header" href="#Тестване-на-cli-приложения-чрез-стартирането-им">Тестване на CLI приложения чрез стартирането им</a></h2>
<p>Дотук малко се отклонихме от темата
, за да тестваме <em>бизнес логиката</em> на нашата програма,
което се оказа функцията <code>find_matches</code>.
Това е много ценна
и страхотна първа стъпка
към добре тествана кодова база.
(Обикновено тези видове тестове се наричат “unit” тестове.)</p>
<p>Обаче има много код, който не тестваме:
Всичко, което напишем, за да се справим с външния свят!
Представете си, че сте написали основната функция,
но случайно оставяте твърдо кодиран низ (статичен низ)
вместо да използвате аргумента на предоставения от потребителя път.
Трябва да пишем тестове и за това!
(Това ниво на тестване често се нарича
“интеграционно тестване”, или “тестване на система”.)</p>
<p>В основата си,
все още пишем функции
и ги анотираме с <code>#[test]</code>.
Въпросът е само какво правим вътре в тези функции.
Например, ще искаме да използваме основния изпълняем файл на нашия проект
и да го стартираме като обикновена програма.
Също така ще поставим тези тестове в нов файл в нова директория:
<code>tests/cli.rs</code>.</p>
<aside>
<p><strong>Забележка:</strong>
По конвенция,
<code>cargo</code> ще търси интеграционни тестове в <code>tests/</code> директорията.
По същия начин,
ще за бенчмарковете в <code>benches/</code>,
и за примерите в <code>examples/</code>.
Тези конвенции се разпростират и върху вашия основен изходен код:
библеотеките имат <code>src/lib.rs</code> файл,
главния изпълням файл е <code>src/main.rs</code>,
или, ако има множество такива файлове,
cargo очаква те да бъдат така <code>src/bin/&lt;name&gt;.rs</code>.
Следването на тези конвенции ще направи кодовата ви база по-откриваема
от хора, свикнали да четат код на Rust.</p>
</aside>
<p>Да си припомним,
<code>grrs</code> е малък инструмент, който търси низ във файл.
Преди това тествахме дали можем да намерим съвпадение.
Нека помислим каква друга функционалност можем да тестваме.</p>
<p>Ето какво измислих.</p>
<ul>
<li>Какво се случва, когато файлът не съществува?</li>
<li>Какъв е резултатът, когато няма съвпадение?</li>
<li>Програмата ни излиза ли с грешка, когато забравим един (или и двата) аргумента?</li>
</ul>
<p>Това са всички валидни тестови случаи.
Освен това,
трябва да включим и един тестов случай
за “щастливия път”,
т.е. намерихме поне едно съвпадение
и го отпечатваме.</p>
<p>За да улесните тези видове тестове,
ще използваме библеотеката <a href="https://docs.rs/assert_cmd"><code>assert_cmd</code></a>.
Има куп спретнати помощници
, които ни позволяват да изпълняваме основния си изпълняем файл
, за да видим как се държи.
По-нататък,
също ще добавим и библеотеката <a href="https://docs.rs/predicates"><code>predicates</code></a>
което ни помага да пишем твърдения
, срещу което <code>assert_cmd</code> може да тества
(и които имат страхотни съобщения за грешки).
Ще добавим тези зависимости не към основния списък,
но към “dev dependencies” секцията в нашия <code>Cargo.toml</code>.
Те са необходими само при разработване на приложението ви,
, а не когато го използвате.</p>
<pre><code class="language-toml">[dev-dependencies]
assert_cmd = &quot;2.0.11&quot;
predicates = &quot;3.0.3&quot;
</code></pre>
<p>Това звучи като много за настройване.
Въпреки това –
нека директно да се потопим
и да създадем нашия <code>tests/cli.rs</code> файл:</p>
<pre><code class="language-rust ignore">use assert_cmd::prelude::*; // Add methods on commands
use predicates::prelude::*; // Used for writing assertions
use std::process::Command; // Run programs

#[test]
fn file_doesnt_exist() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut cmd = Command::cargo_bin(&quot;grrs&quot;)?;

    cmd.arg(&quot;foobar&quot;).arg(&quot;test/file/doesnt/exist&quot;);
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains(&quot;could not read file&quot;));

    Ok(())
}
</code></pre>
<p>Можете да изпълните този тест с
<code>cargo test</code>,
точно като тестовете, които написахме по-горе.
Може да отнеме малко повече време първия път,
тъй като <code>Command::cargo_bin(&quot;grrs&quot;)</code> компилира главния ви изпълняем файл.</p>
<h2 id="Генериране-на-тестови-файлове"><a class="header" href="#Генериране-на-тестови-файлове">Генериране на тестови файлове</a></h2>
<p>Тестът, който току-що видяхме, проверява само дали нашата програма връща съобщение за грешка
когато входният файл не съществува.
Това е важен тест,
но може би не най-важния:
Нека сега да тестваме дали наистина ще отпечатаме съвпаденията, които намерихме във файл!</p>
<p>Ще трябва да имаме файл, чието съдържание знаем,
за да можем да знаем какво <em>трябва</em> да върне нашата програма
и да проверим дали е очакваното в нашия код.
Една идея може да е да добавите файл към проекта с персонализирано съдържание
и да го използвате в тестове си.
Друг начин би било да създадем временни файлове в нашите тестове.
За този урок,
ще разгледаме последния подход.
Основно, защото е по-гъвкав и ще работи и в други случаи;
например, когато тествате програми, които променят файловете.</p>
<p>За да създадете тези временни файлове,
ще трябва да използвате библеотеката <a href="https://docs.rs/assert_fs"><code>assert_fs</code></a>.
Нека го добавим към <code>dev-dependencies</code> в нашия <code>Cargo.toml</code> файл:</p>
<pre><code class="language-toml">assert_fs = &quot;1.0.13&quot;
</code></pre>
<p>Ето нов тестов случай
(което можете да напишете под другото)
, в който първо създавате временен файл
(“наименуван”, за да можем да получим пътя му),
изпълвайте го с някакъв текст,
и след това изпълнете вашата програма
, за да видите дали получаваме правилния резултат.
Когато <code>file</code> излиза извън блока
(в края на функцията),
действителният временен файл автоматично ще бъде изтрит.</p>
<pre><code class="language-rust ignore">use assert_fs::prelude::*;

#[test]
fn find_content_in_file() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let file = assert_fs::NamedTempFile::new(&quot;sample.txt&quot;)?;
    file.write_str(&quot;A test\nActual content\nMore content\nAnother test&quot;)?;

    let mut cmd = Command::cargo_bin(&quot;grrs&quot;)?;
    cmd.arg(&quot;test&quot;).arg(file.path());
    cmd.assert()
        .success()
        .stdout(predicate::str::contains(&quot;test\nAnother test&quot;));

    Ok(())
}
</code></pre>
<aside class="exercise">
<p><strong>Упражнение за читателя:</strong>
Добавете интеграционни тестове за предаване на празен низ като шаблон.
Коригирайте програмата според нуждите.</p>
</aside>
<h2 id="Какво-да-тествате"><a class="header" href="#Какво-да-тествате">Какво да тествате?</a></h2>
<p>Въпреки че, със сигурност, може да бъде забавно да се пишат интеграционни тестове,
ще ви отнеме известно време да ги напишете,
както и да ги актуализирате, когато поведението на вашето приложение се промени.
За да сте сигурни, че използвате времето си разумно,
трябва да се запитате какво трябва да тествате.</p>
<p>Като цяло е добра идея да се пишат интеграционни тестове
за всички видове поведения, които потребителят може да наблюдава.
Това означава, че не е необходимо да покривате всички крайни случаи:
Обикновено е достатъчно да има примери за различните типове
и да разчитайте на <code>unit</code> тестове, за да покриете крайните случаи.</p>
<p>Също така е добра идея да не фокусирате тестовете си върху неща, които не можете да контролирате активно.
Би било лоша идея да тествате точното оформление на <code>--help</code>
тъй като се генерира за вас.
Вместо това може просто да искате да проверите дали определени елементи присъстват.</p>
<p>В зависимост от естеството на вашата програма,
можете също да опитате да добавите още техники за тестване.
Например,
ако сте извлекли части от вашата програма
и установете, че пишете много примерни случаи като <code>unit</code> тестове
докато се опитвате да измислите всички крайни случаи,
трябва да разгледате <a href="https://docs.rs/proptest"><code>proptest</code></a>.
Ако имате програма, която използва произволни файлове и ги анализира,
опитайте се да напишете с техниката <a href="https://rust-fuzz.github.io/book/introduction.html">fuzzer</a>, за да намирате бъгове в крайните случаи.</p>
<aside>
<p><strong>Забележка:</strong>
Можете да намерите пълния изпълним изходен код, използван в тази глава
<a href="https://github.com/rust-cli/book/tree/master/src/tutorial/testing">в хранилището на тази книга</a>.</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Опаковане-и-разпространение-на-rust-инструмент"><a class="header" href="#Опаковане-и-разпространение-на-rust-инструмент">Опаковане и разпространение на Rust инструмент</a></h1>
<p>Ако се чувствате уверени, че вашата програма е готова за използване от други хора,
време е да го опаковате и разпространите!</p>
<p>Има няколко подхода,
и ще разгледаме три от тях
от „най-бърз за настройка“ до „най-удобен за потребителите“.</p>
<h2 id="Най-бързо-cargo-publish"><a class="header" href="#Най-бързо-cargo-publish">Най-бързо: <code>cargo publish</code></a></h2>
<p>Най-лесният начин да публикувате приложението си е с cargo.
Помните ли как добавихме външни зависимости към нашия проект?
Cargoги ги изтегли от стандартната си “регистър за библиотеки”, <a href="https://crates.io/">crates.io</a>.
С <code>cargo publish</code>,
вие също можете да публикувате библиотеките си в <a href="https://crates.io/">crates.io</a>.
И това работи за всички библиотеки,
включително тези с изпълняеми цели.</p>
<p>Публикуване на библиотеки към <a href="https://crates.io/">crates.io</a> е доста просто:
Ако все още не сте го направили, създайте акаунт в <a href="https://crates.io/">crates.io</a>.
В момента това се прави чрез упълномощаване в GitHub,
така че ще трябва да имате акаунт в GitHub
(и да сте влезли там).
След това влизате с cargo на вашата локална машина.
Отидете на
<a href="https://crates.io/me">страницата на акаунта ви в crates.io</a>,
създайте нов токен,
и след това изпълнете <code>cargo login &lt;your-new-token&gt;</code>, като “<your-new-token>”, е токен-а от вашия акаунт.
Трябва да направите това само веднъж на компютъра си.
Можете да научите повече за това
в <a href="https://doc.rust-lang.org/1.39.0/cargo/reference/publishing.html">ръководство за публикуване</a> на cargo.</p>
<p>Сега, когато cargo, както и crates.io ви познават,
вие сте готови да публикувате библиотеките си.
Преди да продължите набързо и да публикувате нова библиотека (версия),
добра идея е да отворите своя <code>Cargo.toml</code> още един път
и да се уверите, че сте добавили необходимите метаданни.
Можете да намерите всички възможни полета, които можете да зададете
в документацията за <a href="https://doc.rust-lang.org/1.39.0/cargo/reference/manifest.html">формата на манифестациите на cargo</a>.
Ето кратък преглед на някои често срещани полета:</p>
<pre><code class="language-toml">[package]
name = &quot;grrs&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;your@email.com&gt;&quot;]
license = &quot;MIT OR Apache-2.0&quot;
description = &quot;A tool to search files&quot;
readme = &quot;README.md&quot;
homepage = &quot;https://github.com/you/grrs&quot;
repository = &quot;https://github.com/you/grrs&quot;
keywords = [&quot;cli&quot;, &quot;search&quot;, &quot;demo&quot;]
categories = [&quot;command-line-utilities&quot;]
</code></pre>
<aside class="note">
<p><strong>Забележка:</strong>
Този пример включва задължителното поле за лиценз
обикновенно избран за Rust проекти:
Същият лиценз, който се използва и за самия компилатор.
Също така има референция към файла <code>README.md</code>.
Този файл трябва да включва кратко описание на това, за което се отнася вашият проект,
тъй като ще бъде включен не само на страницата в crates.io за вашата библиотека,
но и в страницата на хранилището, което GitHub по подразбиране показва.</p>
</aside>
<h3 id="Как-да-инсталирате-изпълняем-файл-от-cratesio"><a class="header" href="#Как-да-инсталирате-изпълняем-файл-от-cratesio">Как да инсталирате изпълняем файл от crates.io</a></h3>
<p>Видяхме как да публикуваме библиотеки в crates.io,
и може би се чудите как да ги инсталирате.
За разлика от библиотеките,
кой cargo ще изтегли и компилира за вас
когато изпълните командата <code>cargo build</code> (или подобен такъв),
ще трябва да му кажете да инсталира изрично изпълняемите файлове.</p>
<p>Това се прави с помощта на командата
<code>cargo install &lt;crate-name&gt;</code>.
По подразбиране ще изтегли библиотеката,
компилира всички изпълняеми цели, които съдържа
(в “release” режим, така че може да отнеме известно време)
и ще ги копира в директорията <code>~/.cargo/bin/</code>.
(Уверете се, че вашата терминал знае да търси там изпълняемите файлове!)</p>
<p>Също така е възможно да
инсталирайте библиотеки от git хранилища,
инсталирайте само конкретни изпълняеми файлове на библиотеките,
и посочете алтернативна директория, в която да ги инсталирате.
Погледнете <code>cargo install --help</code> за детайли.</p>
<h3 id="Кога-да-го-използвате"><a class="header" href="#Кога-да-го-използвате">Кога да го използвате</a></h3>
<p><code>cargo install</code> е лесен начин за инсталиране на изпълняем код.
Много е удобно за разработчиците на Rust да го използват,
но има някои съществени недостатъци:
Тъй като винаги ще компилира вашия източник от нулата,
потребителите на вашия инструмент ще трябва да имат
Rust, cargo, и всички други системни зависимости, които вашият проект изисква
, за да бъдат инсталирани на тяхната машина.
Компилирането на големи кодови бази на Rust също може да отнеме известно време.</p>
<p>Най-добре е да използвате инструменти за разпространение,
които са насочени към други разработчици на Rust.
Например:
Много подкоманди на cargo
като <code>cargo-tree</code> или <code>cargo-outdated</code>
могат да се инсталират с него.</p>
<h2 id="Разпространение-на-изпълняеми-файлове"><a class="header" href="#Разпространение-на-изпълняеми-файлове">Разпространение на изпълняеми файлове</a></h2>
<p>Rust е език, който се компилира в чист код
и по подразбиране свързва статично всички зависимости.
Когато изпълните <code>cargo build</code>
на вашия проект, който съдържа изпълняем файл, наречен <code>grrs</code>,
ще имате друг изпълняем файл, наречен също по същия начин - <code>grrs</code>.
Опитай го:
Когато изпълнявате <code>cargo build</code>, то ви генерира:  <code>target/debug/grrs</code>,
а когато изпълнявате <code>cargo build --release</code>, то ви генерира: <code>target/release/grrs</code>.
Освен ако не използвате библиотеки
които изрично се нуждаят от външни библиотеки, които да бъдат инсталирани на целевата система
(като използване на системната версия на OpenSSL),
този изпълняем файл ще зависи само от общи системни библиотеки.
Това означава,
че ако вземете този файл,
и го изпратите на хора, работещи със същата операционна система като вас,
и те ще могат да го стартират.</p>
<p>Това е много мощно!
Работи около два от недостатъците, които току-що видяхме <code>cargo install</code>:
Не е необходимо да имате инсталиран Rust на машината на потребителя,
и вместо да отнеме минута за компилиране,
те могат незабавно да стартират изпълняемия файл.</p>
<p>И така, както видяхме,
<code>cargo build</code> <em>вече</em>  е изградил изпълняемия файлове за нас.
Единственият проблем е,
не е гарантирано, че работят на всички платформи.
Ако стартирате <code>cargo build</code> на вашата Windows машина,
няма да получите изпълняем файл, който работи на Mac по подразбиране.
Има ли начин да се генерират тези изпълняеми файлове
за всички интересни платформи
автоматично?</p>
<h3 id="Изграждане-на-изпълняеми-версии-със-ci-непрекъсната-интеграция"><a class="header" href="#Изграждане-на-изпълняеми-версии-със-ci-непрекъсната-интеграция">Изграждане на изпълняеми версии със CI (непрекъсната интеграция)</a></h3>
<p>Ако вашият инструмент е с отворен код
и се хоства на GitHub,
доста лесно е да настроите безплатна услуга за CI (непрекъсната интеграция)
като <a href="https://travis-ci.com/">Travis CI</a>.
(Има други услуги, които работят и на други платформи, но Travis е много популярен.)
Това основно изпълнява команди за настройка
във виртуална машина
всеки път, когато направите промени във вашето хранилище.
Какви са тези команди,
и типовете машини, на които работят,
са конфигурируеми.
Например:
Добра идея е да изпълните <code>cargo test</code>
на машина с Rust, което има инсталирани някои общи инструменти за изграждане.
Ако то се провали,
знаете, че имате проблеми в най-новите промени.</p>
<p>Можем да използваме и това
за изграждане на изпълняеми файлове и качването им в GitHub!
Всъщност, ако изпълните
<code>cargo build --release</code>
и качете изпълняемия файл някъде,
всичко трябва да е готови, нали?
Не точно.
Все още трябва да се уверим, че изпълняемите файлове, които изграждаме
са съвместими с възможно най-много системи.
Например,
в Linux среда можем да компилираме не за текущата система,
но и за <code>x86_64-unknown-linux-musl</code>,
за да не зависи от системните библиотеки по подразбиране.
В macOS, можем да зададем стойноста на <code>MACOSX_DEPLOYMENT_TARGET</code> да е <code>10.7</code>,
за да зависи само от системните функции, присъстващи във версии 10.7 и по-стари.</p>
<p>Можете да видите един пример за изграждане на изпълняеми файлове с помощта на този подход
<a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.travis.yml#L74-L91">тука</a> за Linux и macOS
, и <a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.appveyor.yml">тука</a> за Windows (използвайки AppVeyor).</p>
<p>Друг начин е да използвате предварително изградени (Docker) изображения,
които съдържат всички инструменти, от които се нуждаем,
за да изграждаме изпълняеми файлове.
Това ни позволява лесно да се насочваме и към по-екзотични платформи.
Проекта <a href="https://github.com/japaric/trust">trust</a> съдържа
скриптове, които можете да включите във вашия проект
както и инструкции как да ги настроите.
Той също така включва поддръжка за Windows използвайки AppVeyor.</p>
<p>Ако предпочитате да настроите това локално
и da генерирате изходните файловете на вашата собствена машина,
ще е хувабо все пак да погледнете в проекта <code>trust</code>.
То вътрешно използва инструмента <a href="https://github.com/rust-embedded/cross">cross</a>,
, което работи подобно на cargo
но препраща команди към cargo процеса вътре в Docker контейнера.
Дефинициите на изображенията също са налични в
<a href="https://github.com/rust-embedded/cross">хранилището на cross</a>.</p>
<h3 id="Как-да-инсталирате-тези-изпълняеми-файлове"><a class="header" href="#Как-да-инсталирате-тези-изпълняеми-файлове">Как да инсталирате тези изпълняеми файлове</a></h3>
<p>Ако насочваме потребителите си към страницата си на изданието
то може да изглежда <a href="https://github.com/rustwasm/wasm-pack/releases/tag/v0.5.1">подобно на това</a>,
и те могат да изтеглят артефактите, което токущо сме създали.
Артефактите на изданието, които току-що генерирахме, не са нищо особено:
В крайна сметка те са просто архивни файлове, които съдържат нашите изпълняеми файлове!
Това означава, че потребителите на вашия инструмент
могат да ги изтеглят с браузъра си,
да ги разархивират (случва се предимно автоматично),
и да копират тези изпълняеми файлове на място, което им харесва.</p>
<p>Това изисква известен опит с ръчно “инсталиране” на програми,
така че е хубаво да добавите раздел към вашия README файл,
затова как се инсталира вашата програма.</p>
<aside class="note">
<p><strong>Забележка:</strong>
Ако използвате <a href="https://github.com/japaric/trust">trust</a> за да изградите вашите изпълняеми файлове и да ги добавите към изданията на Github,
можете също да кажете на хората да изпълняват командата
<code>curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git your-name/repo-name</code>
ако смятате, че това го прави по-лесно.</p>
</aside>
<h3 id="Кога-да-го-използвате-1"><a class="header" href="#Кога-да-го-използвате-1">Кога да го използвате</a></h3>
<p>Като цяло наличието на изпълняема версии е добра идея,
едва ли има някакъв недостатък в това.
Това не решава проблема с това, че потребителите трябва да правят ръчно
инсталиране и актуализиране
на вашите инструменти,
но те могат бързо да получат най-новата версия
без да е необходимо да инсталират Rust.</p>
<h3 id="Какво-да-пакетирате-в-допълнение-към-вашите-изпълняеми-файлове"><a class="header" href="#Какво-да-пакетирате-в-допълнение-към-вашите-изпълняеми-файлове">Какво да пакетирате в допълнение към вашите изпълняеми файлове</a></h3>
<p>В момента,
когато потребител изтегли нашите компилации от тип <code>release</code>,
те ще получат <code>.tar.gz</code> файл,
което съдържа само изпълняемите файлове.
Така че, в нашия примерен проект,
те ще получат само един <code>grrs</code> файл, което могат да го изпълнят.
Но има още няколко файла, дето вече имаме в нашето хранилище,
които някои биха искали да имат.
Този <code>README</code> файл, което показва как се използва този инструмент,
и файловете за лиценс,
например.
Тъй като вече ги имаме,
те са лесни за добавяне.</p>
<p>Има още интересни файлове
които имат смисъл особено за инструменти за командния ред,
все пак:
Какво ще кажете да изпратим и страница с ръководство в допълнение към този README файл,
и конфигурационни файлове, които добавят завършвания на възможните флагове към вашия терминал?
Можете да ги напишете на ръка,
но <em>clap</em>, библиотеката за разбор на аргументи, която използваме
(на който <em>clap</em> надграждa)
има начин да генерира всички тези файлове за нас.
Погледнете <a href="tutorial/../in-depth/docs.html">това в задълбочените теми</a>
за повече детайли.</p>
<h2 id="Вкарване-на-вашето-приложение-в-хранилища-на-пакети"><a class="header" href="#Вкарване-на-вашето-приложение-в-хранилища-на-пакети">Вкарване на вашето приложение в хранилища на пакети</a></h2>
<p>И двата подхода, които сме виждали досега
не са начинът, по който обикновено инсталирате софтуер на вашата машина.
Особено инструментите за командния ред
ги инсталирате с помощта на глобални мениджъри на пакети
на повечето операционни системи.
Предимствата за потребителите са доста очевидни:
Няма нужда да мислите как да инсталирате вашата програма,
ако може да се инсталира по същия начин, както инсталирате другите инструменти.
Тези мениджъри на пакети също позволяват на потребителите да актуализират своите програми
когато е налична нова версия.</p>
<p>За съжаление, поддържането на различни системи означава
ще трябва да разгледате как работят тези различни системи.
Например,
може да е толкова лесно, колкото добавянето на файл към вашето хранилище
(напр. добавяне на файл с формула като <a href="https://github.com/BurntSushi/ripgrep/blob/31adff6f3c4bfefc9e77df40871f2989443e6827/pkg/brew/ripgrep-bin.rb">това</a> в macOS <code>brew</code>),
но за други често ще трябва сами да изпращате пачове
и да добавяте вашия инструмент към техните хранилища.
Има полезни инструменти като
<a href="https://crates.io/crates/cargo-bundle">cargo-bundle</a>,
<a href="https://crates.io/crates/cargo-deb">cargo-deb</a>, и
<a href="https://crates.io/crates/cargo-aur">cargo-aur</a>,
но описвайки как работят
и как опаковат правилно вашия инструмент
за тези различни системи е извън обхвата на тази глава.</p>
<p>Вместо това,
нека да разгледаме инструмент, който е написан на Rust,
което е налично в много различни мениджъри на пакети.</p>
<h3 id="Например-ripgrep"><a class="header" href="#Например-ripgrep">Например: ripgrep</a></h3>
<p><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> е алтернатива на <code>grep</code>/<code>ack</code>/<code>ag</code> и е написан с Rust.
Той е доста успешен и е пакетиран за много операционни системи:
Просто погледнете <a href="https://github.com/BurntSushi/ripgrep/tree/31adff6f3c4bfefc9e77df40871f2989443e6827#installation">секцията “Installation”</a> на README файла му!</p>
<p>Имайте предвид, че той изброява няколко различни опции как можете да го инсталирате:
Започва с връзка към изданията на GitHub
който съдържа изпълняеми файлове, така че можете да ги изтеглите директно;
след това изброява как да го инсталирате с помощта на куп различни мениджъри на пакети;
и накрая, можете също да го инсталирате с помощта на <code>cargo install</code>.</p>
<p>Това изглежда като много добра идея:
Не избирайте един от подходите, представени тук,
но започнете с <code>cargo install</code>,
добавете изпълняемите издания,
и накрая започнете да разпространявате инструмента си с помощта на системни мениджъри на пакети.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Задълбочени-теми"><a class="header" href="#Задълбочени-теми">Задълбочени теми</a></h1>
<p>Малка колекция от глави, обхващаща повече подробности
които може да ви интересуват, когато пишете вашето приложение за команден ред.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Обработка-на-сигнали"><a class="header" href="#Обработка-на-сигнали">Обработка на сигнали</a></h1>
<p>Процеси,
като приложения от командния ред,
трябва да реагира на сигнали, изпратени от операционната система.
Най-често срещаният пример е може би <kbd>Ctrl</kbd>+<kbd>C</kbd>,
сигналът, който обикновено казва на процес да прекрати.
За обработка на сигнали в програми на Rust
трябва да обмислите как можете да получавате тези сигнали
както и как можете да реагирате на тях.</p>
<aside>
<p><strong>Забележка:</strong>
Ако вашите приложения не се нуждаят от елегантно изключване,
обработката по подразбиране е достатъчна
(т.е. излезте веднага
и оставяте операционната система да почиства ресурсите, като манипулатори за отваряне на файлове и др.).
В този случай:
Няма нужда да правите това, което ви казва тази глава!</p>
<p>Обаче,
за приложения, които трябва да почистват след себе си,
тази глава е много подходяща!
Например,
ако приложението ви трябва
правилно да затвори мрежовите връзки
(казвайки “довиждане” на процесите в другия край),
да премахва временни файлове,
или да нулира системните настройки,
прочетете нататък.</p>
</aside>
<h2 id="Разлики-между-операционните-системи"><a class="header" href="#Разлики-между-операционните-системи">Разлики между операционните системи</a></h2>
<p>В <code>Unix</code> системи
(като Linux, macOS, и FreeBSD)
даден процес може да получи <a href="https://manpages.ubuntu.com/manpages/bionic/en/man7/signal.7.html">сигнали</a>.
То може или да реагира на тях
по стандартен (осигурен от операционната система) начин,
да хване сигнала и да го обработва по програмно дефиниран начин,
или да игнорира сигнала напълно.</p>
<p><code>Windows</code> няма сигнали.
Можеш да използваш <a href="https://docs.microsoft.com/en-us/windows/console/console-control-handlers">Конзолни манипулатори</a>
за дефиниране на обратни извиквания, които се изпълняват при възникване на събитие.
Има и [структурирана обработка на грешките]
който обработва всички различни видове системни грешки като делене на нула, грешки за невалиден достъп, препълване на стека и т.н.</p>
<h2 id="Първо-Обработване-на-ctrlc"><a class="header" href="#Първо-Обработване-на-ctrlc">Първо: Обработване на Ctrl+C</a></h2>
<p>Библиотеката <a href="https://crates.io/crates/ctrlc">ctrlc</a> прави точно това, което подсказва името:
Позволява ви да реагирате на сигналите от потребителя с <kbd>Ctrl</kbd>+<kbd>C</kbd>,
по междуплатформен начин.
Основният начин за използване на библиотеката е следният:</p>
<pre><code class="language-rust ignore">use std::{thread, time::Duration};

fn main() {
    ctrlc::set_handler(move || {
        println!(&quot;received Ctrl+C!&quot;);
    })
    .expect(&quot;Error setting Ctrl-C handler&quot;);

    // Following code does the actual work, and can be interrupted by pressing
    // Ctrl-C. As an example: Let's wait a few seconds.
    thread::sleep(Duration::from_secs(2));
}
</code></pre>
<p>Това, разбира се, не е толкова полезно:
Той само отпечатва съобщение, но иначе не спира програмата.</p>
<p>В програма от реалния свят,
добра идея е вместо това да зададете променлива в манипулатора на сигнали
това и да го проверявате на различни места във вашата програма.
Например,
можете да зададете <code>Arc&lt;AtomicBool&gt;</code>
(булева стойност за споделяне между нишки)
във вашия манипулатор на сигнали,
и във важни цикли,
или когато чакате нишка,
периодично да проверите стойността му
и да спрете когато то стане <code>true</code>.</p>
<h2 id="Работа-с-други-видове-сигнали"><a class="header" href="#Работа-с-други-видове-сигнали">Работа с други видове сигнали</a></h2>
<p>Библиотеката <a href="https://crates.io/crates/ctrlc">ctrlc</a> обработва само комбинацията <kbd>Ctrl</kbd>+<kbd>C</kbd>,
или, как би се наричало в Unix системите <code>SIGINT</code> (сигнал за “прекъсване”).
За да реагирате на повече Unix сигнали,
трябва да погледнете в <a href="https://crates.io/crates/signal-hook">signal-hook</a>.
Дизайнът му е описан в <a href="https://vorner.github.io/2018/06/28/signal-hook.html">този блог</a>,
и в момента е библиотеката с най-широка обществена подкрепа.</p>
<p>Ето и един прост пример:</p>
<pre><code class="language-rust ignore">use signal_hook::{consts::SIGINT, iterator::Signals};
use std::{error::Error, thread, time::Duration};

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let mut signals = Signals::new(&amp;[SIGINT])?;

    thread::spawn(move || {
        for sig in signals.forever() {
            println!(&quot;Received signal {:?}&quot;, sig);
        }
    });

    // Following code does the actual work, and can be interrupted by pressing
    // Ctrl-C. As an example: Let's wait a few seconds.
    thread::sleep(Duration::from_secs(2));

    Ok(())
}
</code></pre>
<h2 id="Използване-на-канали"><a class="header" href="#Използване-на-канали">Използване на канали</a></h2>
<p>Вместо да зададете променлива
и да имате други части на програмата да я проверят,
можете да използвате канали:
Можете да създавате канали, в които манипулаторите на сигнали да излъчват стойности
когато даден сигнал е приет.
В кода на вашето приложение ги използвате
тези и други канали
като точки за синхронизация между нишки.
Използвайки библиотеката <a href="https://crates.io/crates/crossbeam-channel">crossbeam-channel</a> то би изглеждало така:</p>
<pre><code class="language-rust ignore">use std::time::Duration;
use crossbeam_channel::{bounded, tick, Receiver, select};
use anyhow::Result;

fn ctrl_channel() -&gt; Result&lt;Receiver&lt;()&gt;, ctrlc::Error&gt; {
    let (sender, receiver) = bounded(100);
    ctrlc::set_handler(move || {
        let _ = sender.send(());
    })?;

    Ok(receiver)
}

fn main() -&gt; Result&lt;()&gt; {
    let ctrl_c_events = ctrl_channel()?;
    let ticks = tick(Duration::from_secs(1));

    loop {
        select! {
            recv(ticks) -&gt; _ =&gt; {
                println!(&quot;working!&quot;);
            }
            recv(ctrl_c_events) -&gt; _ =&gt; {
                println!();
                println!(&quot;Goodbye!&quot;);
                break;
            }
        }
    }

    Ok(())
}
</code></pre>
<h2 id="Използване-на-фючъри-и-потоци"><a class="header" href="#Използване-на-фючъри-и-потоци">Използване на фючъри и потоци</a></h2>
<p>Ако използвате <a href="https://tokio.rs/">tokio</a>,
най-вероятно вече пишете вашето приложение
с асинхронни модели и дизайн, управляван от събития.
Вместо да използвате директно каналите на <code>crossbeam</code>,
можете да активирате функцията <code>tokio-support</code> на signal-hook.
Това ви позволява да извикате <a href="https://docs.rs/signal-hook/0.1.6/signal_hook/iterator/struct.Signals.html#method.into_async"><code>.into_async()</code></a>
върху типовете <code>Signals</code> от signal-hook
за да получите нов тип, който имплементира <code>futures::Stream</code>.</p>
<h2 id="Какво-да-направите-когато-получите-друга-ctrlc-докато-се-справяте-с-първия-ctrlc"><a class="header" href="#Какво-да-направите-когато-получите-друга-ctrlc-докато-се-справяте-с-първия-ctrlc">Какво да направите, когато получите друга Ctrl+C докато се справяте с първия Ctrl+C</a></h2>
<p>Повечето потребители ще натиснат <kbd>Ctrl</kbd>+<kbd>C</kbd>,
и след това ще изчакат програмата ви няколко секунди да излезе,
или да им кажете какво става.
Ако това не се случи,
ще натискат <kbd>Ctrl</kbd>+<kbd>C</kbd> отново и отново.
Типичното поведение е приложението да се затвори незабавно.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Използване-на-конфигурационни-файлове"><a class="header" href="#Използване-на-конфигурационни-файлове">Използване на конфигурационни файлове</a></h1>
<p>Работата с конфигурации може да бъде досадна
особено ако поддържате няколко операционни системи
които всички имат свои собствени места
за краткосрочни и дългосрочни файлове.</p>
<p>Има множество решения за този проблем,
някои дето са на по-ниско ниво от други.</p>
<p>Най-лесния начин е да използвате библеотеката <a href="https://docs.rs/confy/0.3.1/confy/"><code>confy</code></a>.
Той ви пита за името на вашето приложение
и изисква да посочите оформлението на конфигурацията
чрез <code>struct</code> (което наследява <code>Serialize</code>, <code>Deserialize</code>)
и то ще разбере останалото!</p>
<pre><code class="language-rust ignore">#[derive(Debug, Serialize, Deserialize)]
struct MyConfig {
    name: String,
    comfy: bool,
    foo: i64,
}

fn main() -&gt; Result&lt;(), io::Error&gt; {
    let cfg: MyConfig = confy::load(&quot;my_app&quot;)?;
    println!(&quot;{:#?}&quot;, cfg);
    Ok(())
}
</code></pre>
<p>Това е невероятно лесно за използване
за което, разбира се, се отказвате от възможностите за конфигуриране.
Но ако простата конфигурация е всичко, което искате,
тази библиотека може да е за вас!</p>
<h2 id="Конфигурационни-среди"><a class="header" href="#Конфигурационни-среди">Конфигурационни среди</a></h2>
<aside class="todo">
<p><strong>Задачи</strong></p>
<ol>
<li>Оценете библиотеките, които съществуват</li>
<li>Аргументи от конзолата + множество конфигурации + <code>env</code> променливи</li>
<li>Може ли <a href="https://docs.rs/configure/0.1.1/configure/"><code>configure</code></a> да направи всичко това? Има ли нещо хубаво, за да го обвием?</li>
</ol>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Кодове-за-изход"><a class="header" href="#Кодове-за-изход">Кодове за изход</a></h1>
<p>Работата на една програма не винаги завършва успешно.
И когато възникне грешка,
трябва да се уверите, че предавате правилно необходимата информация.
В допълнение към
<a href="in-depth/human-communication.html">уведомяването на потребителите за грешки</a>,
на повечето системи,
когато процесът излезе,
той също предава код за изход
(цяло число между 0 и 255 е съвместимо с повечето платформи).
Трябва да опитате да предавате правилния код
за състоянието на вашата програма.
Например,
в идеалния случай, когато вашата програма завърши успешно,
то трябва да излезе с код <code>0</code>.</p>
<p>Когато се появи грешка нещата стават малко по сложни.
В реалния свят,
много инструменти излизат с код <code>1</code> когато възникне обща грешка.
В момента Rust задава код за изход <code>101</code>, когато процесът се паникьоса.
Освен това хората са направили много неща в своите програми.</p>
<p>И така, какво да правим?
Екосистемата <code>BSD</code> е събрала обща дефиниция за техните изходни кодове
(можете да ги намерите <a href="https://www.freebsd.org/cgi/man.cgi?query=sysexits&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+11.2-stable&amp;arch=default&amp;format=html">тук</a>).
Библиотеката <a href="https://crates.io/crates/exitcode"><code>exitcode</code></a> предоставя същите тези кодове,
готови за използване във вашето приложение.
Моля, вижте неговата API документация за възможните стойности, които да използвате.</p>
<p>След като добавите зависимостта <code>exitcode</code> към вашия <code>Cargo.toml</code>,
можете да го използвате така:</p>
<pre><code class="language-rust ignore">fn main() {
    // ...actual work...
    match result {
        Ok(_) =&gt; {
            println!(&quot;Done!&quot;);
            std::process::exit(exitcode::OK);
        }
        Err(CustomError::CantReadConfig(e)) =&gt; {
            eprintln!(&quot;Error: {}&quot;, e);
            std::process::exit(exitcode::CONFIG);
        }
        Err(e) =&gt; {
            eprintln!(&quot;Error: {}&quot;, e);
            std::process::exit(exitcode::DATAERR);
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Общуване-с-хора"><a class="header" href="#Общуване-с-хора">Общуване с хора</a></h1>
<p>Не забравяйте да прочетете <a href="in-depth/../tutorial/output.html">главата за изхода към терминала</a>
в първото ръководство.
Той обхваща как да запишете изход към терминала,
докато тази глава ще говори за <em>какво</em> да се изведе.</p>
<h2 id="Когато-всичко-е-наред"><a class="header" href="#Когато-всичко-е-наред">Когато всичко е наред</a></h2>
<p>Полезно е да докладвате за напредъка на приложението
дори когато всичко е наред.
Опитайте се да бъдете информативни и кратки в тези съобщения.
Не използвайте прекалено технически термини в регистрационните файлове.
Запомнете:
приложението не се срива
така че няма причина потребителите да търсят грешки.</p>
<p>Най-важното,
бъдете постоянни в стила на общуване.
Използвайте същите префикси и структура на изреченията
за да направите логовете лесни за разбиране.</p>
<p>Опитайте се да оставите изхода на вашето приложение да разказва история
за това какво прави
и как се отразява на потребителя.
Това може да включва показване на времева линия на включените стъпки
или дори лента за напредък и индикатор за дълготрайни действия.
Потребителят не трябва в нито един момент
да има чувството, че приложението прави нещо мистериозно
и че не могат да го следват.</p>
<h2 id="Когато-е-трудно-да-се-каже-какво-се-случва"><a class="header" href="#Когато-е-трудно-да-се-каже-какво-се-случва">Когато е трудно да се каже какво се случва</a></h2>
<p>Когато комуникирате неноминално състояние, важно е да сте последователни.
Приложение със силно логване, което не следва стриктни нива на регистриране
предоставя същото количество или дори по-малко информация
отколкото приложение без логове.</p>
<p>Заради това,
важно е да се определи сериозността на събитията
и съобщения, които са свързани с него;
след това използвайте последователни нива на логове за тях.
По този начин потребителите могат сами да избират количеството логове
чрез флагове <code>--verbose</code>
или променливи на средата (като <code>RUST_LOG</code>).</p>
<p>Често използваната библиотеки за логваме <code>log</code>
<a href="https://docs.rs/log/0.4.4/log/enum.Level.html">дефинира</a> следните нива
(подредени по нарастваща тежест):</p>
<ul>
<li>trace</li>
<li>debug</li>
<li>info</li>
<li>warning</li>
<li>error</li>
</ul>
<p>Добра идея е да мислите за <em>info</em> като ниво за логване по подразбиране.
Използвайте го като информативен изход.
(Някои приложения, които са клонни към по-тих стил на извеждане
може да показва само предупреждения и грешки по подразбиране.)</p>
<p>Допълнително,
винаги е добра идея да използвате подобни префикси
и структура на изреченията в съобщенията в логовете,
което улеснява използването на инструмент като <code>grep</code> за филтрирането им.
Самото съобщение трябва да предоставя достатъчно контекст
за да е полезен във филтрирани логовете,
но и в същото време не е и <em>твърде</em> информативен.</p>
<h3 id="Примерни-логове"><a class="header" href="#Примерни-логове">Примерни логове</a></h3>
<pre><code class="language-console">error: could not find `Cargo.toml` in `/home/you/project/`
</code></pre>
<pre><code class="language-console">=&gt; Downloading repository index
=&gt; Downloading packages...
</code></pre>
<p>Следният лог изход е взет от <a href="https://crates.io/crates/wasm-pack">wasm-pack</a>:</p>
<pre><code class="language-console"> [1/7] Adding WASM target...
 [2/7] Compiling to WASM...
 [3/7] Creating a pkg directory...
 [4/7] Writing a package.json...
 &gt; [WARN]: Field `description` is missing from Cargo.toml. It is not necessary, but recommended
 &gt; [WARN]: Field `repository` is missing from Cargo.toml. It is not necessary, but recommended
 &gt; [WARN]: Field `license` is missing from Cargo.toml. It is not necessary, but recommended
 [5/7] Copying over your README...
 &gt; [WARN]: origin crate has no README
 [6/7] Installing WASM-bindgen...
 &gt; [INFO]: wasm-bindgen already installed
 [7/7] Running WASM-bindgen...
 Done in 1 second
</code></pre>
<h2 id="При-паникьосване"><a class="header" href="#При-паникьосване">При паникьосване</a></h2>
<p>Един от аспектите, който често се забравя, е това, че
вашата програма също извежда нещо, когато се срине.
В Rust, “сривовете” най-често са “паника”
(т.е. „контролиран срив“
за разлика от това „операционната система да убе процеса“).
По подразбиране,
когато настъпи паника,
“паник манипулатор” ще отпечата някаква информация на конзолата</p>
<p>Например,
ако създадете нов бинарен проект
с командата <code>cargo new --bin foo</code>
и заменете съдържанието на <code>fn main</code> с <code>panic!(&quot;Hello World&quot;)</code>,
получавате това, когато стартирате вашата програма:</p>
<pre><code class="language-console">thread 'main' panicked at 'Hello, world!', src/main.rs:2:5
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Това е полезна информация за вас, разработчика.
(Изненада: програмата се срина поради ред 2 във вашия файл <code>main.rs</code>).
Но за потребител, който дори няма достъп до изходния код,
това не е много ценно.
Всъщност най-вероятно е просто объркващо.
Ето защо е добра идея да добавите персонализиран манипулатор на паника,
което осигурява малко по-фокусиран към крайния потребител резултат.</p>
<p>Една библиотека, която прави точно това и се нарича <a href="https://crates.io/crates/human-panic">human-panic</a>.
За да го добавите към конзолния ви проект,
импортирайте го
и извикайте макрото <code>setup_panic!()</code>
в началото на вашата <code>main</code> функция:</p>
<pre><code class="language-rust ignore">use human_panic::setup_panic;

fn main() {
   setup_panic!();

   panic!(&quot;Hello world&quot;)
}
</code></pre>
<p>Това вече ще покаже много приятелско съобщение,
и казва на потребителя какво може да направи:</p>
<pre><code class="language-console">Well, this is embarrassing.

foo had a problem and crashed. To help us diagnose the problem you can send us a crash report.

We have generated a report file at &quot;/var/folders/n3/dkk459k908lcmkzwcmq0tcv00000gn/T/report-738e1bec-5585-47a4-8158-f1f7227f0168.toml&quot;. Submit an issue or email with the subject of &quot;foo Crash Report&quot; and include the report as an attachment.

- Authors: Your Name &lt;your.name@example.com&gt;

We take privacy seriously, and do not perform any automated error collection. In order to improve the software, we rely on people to submit reports.

Thank you kindly!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Общуване-с-машини"><a class="header" href="#Общуване-с-машини">Общуване с машини</a></h1>
<p>Силата на инструментите на командния ред наистина излиза наяве
когато можете да ги комбинирате.
Това не е нова идея:
Всъщност това е изречение от [философията на Unix]:</p>
<blockquote>
<p>Очаквайте изхода на всяка програма да стане вход за друга, все още неизвестна програма.</p>
</blockquote>
<p>[философията на Unix]: <a href="https://en.wikipediaUnix">https://en.wikipediaUnix</a> philosophy.org/wiki/Unix_philosophy</p>
<p>Ако нашите програми изпълнят това очакване,
нашите потребители ще бъдат доволни.
За да сте сигурни, че това работи добре,
ние трябва да осигурим не просто красив резултат за хората,
но също и версия, съобразена с това, от което се нуждаят други програми.
Нека да видим как можем да направим това.</p>
<aside>
<p><strong>Забележка:</strong>
Не забравяйте да прочетете <a href="in-depth/../tutorial/output.html">главата за изход за хора и машини</a>
пo първото ръководство.
Той обхваща как да записвате изход към терминала.</p>
</aside>
<h2 id="Кой-чете-това"><a class="header" href="#Кой-чете-това">Кой чете това?</a></h2>
<p>Първият въпрос, който трябва да зададете е:
Дали нашата продукция за човек пред цветен терминал,
или за друга програма?
За да отговорите на това,
можете да използвате библиоте като <a href="https://crates.io/crates/is-terminal">is-terminal</a>:</p>
<pre><code class="language-rust ignore">use is_terminal::IsTerminal as _;

if std::io::stdout().is_terminal() {
    println!(&quot;I'm a terminal&quot;);
} else {
    println!(&quot;I'm not&quot;);
}
</code></pre>
<p>В зависимост от това кой ще прочете нашия резултат,
можем да добавим допълнителна информация.
Хората са склонни да харесват цветовете,
например,
ако стартирате <code>ls</code> в случаен Rust проект,
може да видите нещо подобно:</p>
<pre><code class="language-console">$ ls
CODE_OF_CONDUCT.md   LICENSE-APACHE       examples
CONTRIBUTING.md      LICENSE-MIT          proptest-regressions
Cargo.lock           README.md            src
Cargo.toml           convey_derive        target
</code></pre>
<p>Тъй като този стил е създаден за хората,
в повечето конфигурации
дори ще отпечата някои от имената (като <code>src</code>) в цвят
за да покажат, че са директории.
Ако вместо това насочите това към файл,
или програма като <code>cat</code>,
<code>ls</code> ще адаптира своя изход.
Вместо да използвам колони, които отговарят на моя терминален прозорец
той ще отпечата всеки запис на отделен ред.
Освен това няма да излъчва никакви цветове.</p>
<pre><code class="language-console">$ ls | cat
CODE_OF_CONDUCT.md
CONTRIBUTING.md
Cargo.lock
Cargo.toml
LICENSE-APACHE
LICENSE-MIT
README.md
convey_derive
examples
proptest-regressions
src
target
</code></pre>
<h2 id="Лесни-изходни-формати-за-машини"><a class="header" href="#Лесни-изходни-формати-за-машини">Лесни изходни формати за машини</a></h2>
<p>Исторически,
единственият тип изходен код от конзолните приложения бяха низове.
Това обикновено е добре за хората пред терминала,
които могат да четат текста
и разсъждават за значението му.
Други програми обаче обикновено нямат тази възможност:
Единственият начин те да разберат резултата от даден инструмент
като <code>ls</code>
е ако авторът на програмата е включил анализатор
за да работи с каквито и да е изходи на <code>ls</code>.</p>
<p>Това често означава, че
този изход бе ограничен до това, което е лесно за анализиране.
Формати като TSV (стойности, разделени с табулации),
където всеки запис е на отделен ред,
и всеки ред съдържа съдържание, разделено с табулации,
са много популярни.
Тези прости формати, базирани на редове текст
позволяват на инструменти като <code>grep</code>
да използват изхода на инструменти като <code>ls</code>.
Командата <code>| grep Cargo</code> не се интересува дали редовете ви са от <code>ls</code> или файл,
то просто ще филтрира ред по ред.</p>
<p>Недостатъкът на това е, че не можете да използвате
<code>grep</code> като лесно да го извикате за филтриране на всички директории, които <code>ls</code> ви подава.
За целта всеки елемент от директорията ще трябва да носи допълнителни данни.</p>
<h2 id="json-изход-за-машини"><a class="header" href="#json-изход-за-машини">JSON изход за машини</a></h2>
<p>Стойностите, разделени с разделители, са лесен начин
за извеждане на структурирани данни,
но изисква другата програма да знае кои полета да очаква
(и в какъв ред)
и е трудно да се извеждат съобщения от различни типове.
Например,
да кажем, че нашата програма иска да изпрати съобщение до потребителя
че в момента чака изтеглянето,
и след това ще изведе съобщение, описващо получените данни.
Това са много различни видове съобщения
и опита да ги обединим в TSV изход
ще изисква от нас да измислим начин да ги разграничим.
Същото, когато искаме да отпечатаме съобщение, което съдържа два списъка
от предмети с различна дължина.</p>
<p>Все още,
добра идея е да изберете формат, който лесно се анализира
в повечето програмни езици/среди.
По този начин,
през последните години много приложения придобиха възможността
за извеждане на техните данни в <a href="https://www.json.org/">JSON</a>.
То е достатъчно прост формат, че практически всеки език има анализатори за него
но и достатъчно мощен, за да бъде полезен в много случаи.
Въпреки че е текстов формат, който може да се чете от хора,
много хора са работили върху имплементации, които са много бързи
при анализиране на JSON данни и сериализиране на данни в JSON.</p>
<p>В описанието по-горе,
говорихме за “съобщения”, написани от нашата програма.
Това е добър начин да мислите за изхода:
Вашата програма не извежда непременно само един блок от данни
но всъщност може да излъчва много различна информация
докато работи.
Един лесен начин за поддържане на този подход при извеждане на JSON
е да напишете един JSON документ на съобщение
и да поставяте всеки JSON документ на нов ред
(понякога наричан <a href="https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON">JSON с разделени редове</a>).
Това може да направи имплементациите толкова прости, колкото използването на обикновен <code>println!</code>.</p>
<p>Ето един прост пример,
използвайки макро <code>json!</code> от библиотеката <a href="https://crates.io/crates/serde_json">serde_json</a>
за бързо записване на валиден JSON във вашия изходен код на Rust:</p>
<pre><code class="language-rust ignore">use clap::Parser;
use serde_json::json;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(Parser)]
struct Cli {
    /// Output JSON instead of human readable messages
    #[arg(long = &quot;json&quot;)]
    json: bool,
}

fn main() {
    let args = Cli::parse();
    if args.json {
        println!(
            &quot;{}&quot;,
            json!({
                &quot;type&quot;: &quot;message&quot;,
                &quot;content&quot;: &quot;Hello world&quot;,
            })
        );
    } else {
        println!(&quot;Hello world&quot;);
    }
}
</code></pre>
<p>Ето и изхода:</p>
<pre><code class="language-console">$ cargo run -q
Hello world
$ cargo run -q -- --json
{&quot;content&quot;:&quot;Hello world&quot;,&quot;type&quot;:&quot;message&quot;}
</code></pre>
<p>(Стартирането на <code>cargo</code> с <code>-q</code> потиска обичайния му изход.
Аргументите след „–“ се предават на нашата програма.)</p>
<h3 id="Практически-пример-ripgrep"><a class="header" href="#Практически-пример-ripgrep">Практически пример: ripgrep</a></h3>
<p><em><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a></em> е заместител на <em>grep</em> или <em>ag</em>, написан на Rust.
По подразбиране ще генерира изход по следния начин:</p>
<pre><code class="language-console">$ rg default
src/lib.rs
37:    Output::default()

src/components/span.rs
6:    Span::default()
</code></pre>
<p>Но ако подадем <code>--json</code> то ще принтира:</p>
<pre><code class="language-console">$ rg default --json
{&quot;type&quot;:&quot;begin&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/lib.rs&quot;}}}
{&quot;type&quot;:&quot;match&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/lib.rs&quot;},&quot;lines&quot;:{&quot;text&quot;:&quot;    Output::default()\n&quot;},&quot;line_number&quot;:37,&quot;absolute_offset&quot;:761,&quot;submatches&quot;:[{&quot;match&quot;:{&quot;text&quot;:&quot;default&quot;},&quot;start&quot;:12,&quot;end&quot;:19}]}}
{&quot;type&quot;:&quot;end&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/lib.rs&quot;},&quot;binary_offset&quot;:null,&quot;stats&quot;:{&quot;elapsed&quot;:{&quot;secs&quot;:0,&quot;nanos&quot;:137622,&quot;human&quot;:&quot;0.000138s&quot;},&quot;searches&quot;:1,&quot;searches_with_match&quot;:1,&quot;bytes_searched&quot;:6064,&quot;bytes_printed&quot;:256,&quot;matched_lines&quot;:1,&quot;matches&quot;:1}}}
{&quot;type&quot;:&quot;begin&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/components/span.rs&quot;}}}
{&quot;type&quot;:&quot;match&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/components/span.rs&quot;},&quot;lines&quot;:{&quot;text&quot;:&quot;    Span::default()\n&quot;},&quot;line_number&quot;:6,&quot;absolute_offset&quot;:117,&quot;submatches&quot;:[{&quot;match&quot;:{&quot;text&quot;:&quot;default&quot;},&quot;start&quot;:10,&quot;end&quot;:17}]}}
{&quot;type&quot;:&quot;end&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/components/span.rs&quot;},&quot;binary_offset&quot;:null,&quot;stats&quot;:{&quot;elapsed&quot;:{&quot;secs&quot;:0,&quot;nanos&quot;:22025,&quot;human&quot;:&quot;0.000022s&quot;},&quot;searches&quot;:1,&quot;searches_with_match&quot;:1,&quot;bytes_searched&quot;:5221,&quot;bytes_printed&quot;:277,&quot;matched_lines&quot;:1,&quot;matches&quot;:1}}}
{&quot;data&quot;:{&quot;elapsed_total&quot;:{&quot;human&quot;:&quot;0.006995s&quot;,&quot;nanos&quot;:6994920,&quot;secs&quot;:0},&quot;stats&quot;:{&quot;bytes_printed&quot;:533,&quot;bytes_searched&quot;:11285,&quot;elapsed&quot;:{&quot;human&quot;:&quot;0.000160s&quot;,&quot;nanos&quot;:159647,&quot;secs&quot;:0},&quot;matched_lines&quot;:2,&quot;matches&quot;:2,&quot;searches&quot;:2,&quot;searches_with_match&quot;:2}},&quot;type&quot;:&quot;summary&quot;}
</code></pre>
<p>Както виждате,
всеки JSON документ е обект (шаблон) съдържащо поле <code>type</code>.
Това ще ни позволи да напишем прост интерфейс за <code>rg</code>
който чете тези документи, когато влязат и показват съвпаденията
(както и файловете, в които се намират)
дори докато <em>ripgrep</em> все още търси.</p>
<aside>
<p><strong>Забелжка:</strong>
Ето как Visual Studio Code използва <em>ripgrep</em> за своето търсене в кода.</p>
</aside>
<h2 id="Как-да-се-справим-с-подадената-информация"><a class="header" href="#Как-да-се-справим-с-подадената-информация">Как да се справим с подадената информация</a></h2>
<p>Да приемем, че имаме програма, която чете броя на думите във файл:</p>
<pre><code class="language-rust ignore">use clap::Parser;
use std::path::PathBuf;

/// Count the number of lines in a file
#[derive(Parser)]
#[command(arg_required_else_help = true)]
struct Cli {
    /// The path to the file to read
    file: PathBuf,
}

fn main() {
    let args = Cli::parse();
    let mut word_count = 0;
    let file = args.file;

    for line in std::fs::read_to_string(&amp;file).unwrap().lines() {
        word_count += line.split(' ').count();
    }

    println!(&quot;Words in {}: {}&quot;, file.to_str().unwrap(), word_count)
}
</code></pre>
<p>Той взема пътя до файл, чете го ред по ред и брои броя
думи, разделени с интервал.</p>
<p>Когато го стартирате, той извежда общия брой думи във файла:</p>
<pre><code class="language-console">$ cargo run README.md
Words in README.md: 47
</code></pre>
<p>Но какво ще стане, ако искаме да преброим броя на думите, въведени в програмата?
Програмите на Rust могат да четат данни, предадени чрез stdin <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html">със структурата Stdin</a>, която можете да получите чрез <a href="https://doc.rust-lang.org/std/io/fn.stdin.html">функцията stdin</a>
от стандартната библиотека. Подобно на четенето на редовете от файл, той може да чете
и редовете от stdin.</p>
<p>Ето една програма, която брои думите на това, което е въведено чрез stdin</p>
<pre><code class="language-rust ignore">use clap::{CommandFactory, Parser};
use is_terminal::IsTerminal as _;
use std::{
    fs::File,
    io::{stdin, BufRead, BufReader},
    path::PathBuf,
};

/// Count the number of lines in a file or stdin
#[derive(Parser)]
#[command(arg_required_else_help = true)]
struct Cli {
    /// The path to the file to read, use - to read from stdin (must not be a tty)
    file: PathBuf,
}

fn main() {
    let args = Cli::parse();

    let word_count;
    let mut file = args.file;

    if file == PathBuf::from(&quot;-&quot;) {
        if stdin().is_terminal() {
            Cli::command().print_help().unwrap();
            ::std::process::exit(2);
        }

        file = PathBuf::from(&quot;&lt;stdin&gt;&quot;);
        word_count = words_in_buf_reader(BufReader::new(stdin().lock()));
    } else {
        word_count = words_in_buf_reader(BufReader::new(File::open(&amp;file).unwrap()));
    }

    println!(&quot;Words from {}: {}&quot;, file.to_string_lossy(), word_count)
}

fn words_in_buf_reader&lt;R: BufRead&gt;(buf_reader: R) -&gt; usize {
    let mut count = 0;
    for line in buf_reader.lines() {
        count += line.unwrap().split(' ').count()
    }
    count
}
</code></pre>
<p>Ако стартирате тази програма с текст, въведен по канал, с <code>-</code>, представляващ намерението
за четене от <code>stdin</code>, тя ще изведе броя на думите:</p>
<pre><code class="language-console">$ echo &quot;hi there friend&quot; | cargo run -- -
Words from stdin: 3
</code></pre>
<p>Изисква се това че stdin не е интерактивно, защото очакваме вход, което
предаден до програмата, а не текст, въведен по време на изпълнение. Ако stdin е
a <code>tty</code>, извежда помощните документи, така че е ясно защо не работи.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Рендиране-на-документация-за-вашето-конзолно-приложение"><a class="header" href="#Рендиране-на-документация-за-вашето-конзолно-приложение">Рендиране на документация за вашето конзолно приложение</a></h1>
<p>Документации за конзолните приложения предимно се състои
в секция на командата <code>--help</code>
и страницата на <code>man</code>.</p>
<p>И двете могат да се генерират автоматично
когато използвате <a href="https://crates.io/crates/clap"><code>clap</code></a>, чрез
библиотеката <a href="https://crates.io/crates/clap_mangen"><code>clap_mangen</code></a>.</p>
<pre><code class="language-rust ignore">#[derive(Parser)]
pub struct Head {
    /// file to load
    pub file: PathBuf,
    /// how many lines to print
    #[arg(short = &quot;n&quot;, default_value = &quot;5&quot;)]
    pub count: usize,
}
</code></pre>
<p>Второ, трябва да използвате <code>build.rs</code>
за да генерирате ръчен файл по време на компилиране
от дефиницията на вашето приложение
в кода.</p>
<p>Трябва да имате предвид няколко неща
(като например как искате да опаковате своя изпълняем файл)
но засега
ние просто поставяме файла <code>man</code>
до нашата папка <code>src</code>.</p>
<pre><code class="language-rust ignore">use clap::CommandFactory;

#[path=&quot;src/cli.rs&quot;]
mod cli;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let out_dir = std::path::PathBuf::from(std::env::var_os(&quot;OUT_DIR&quot;).ok_or_else(|| std::io::ErrorKind::NotFound)?);
    let cmd = cli::Head::command();

    let man = clap_mangen::Man::new(cmd);
    let mut buffer: Vec&lt;u8&gt; = Default::default();
    man.render(&amp;mut buffer)?;

    std::fs::write(out_dir.join(&quot;head.1&quot;), buffer)?;

    Ok(())
}
</code></pre>
<p>Когато сега компилирате вашето приложение
ще има файл <code>head.1</code>
в директорията на вашия проект.</p>
<p>Ако отворите това в <code>man</code>.
ще можете да се насладите на вашата безплатна документация.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Ресурси"><a class="header" href="#Ресурси">Ресурси</a></h1>
<p>Сътрудничество / помощ</p>
<ul>
<li><a href="https://discord.com/channels/273534239310479360/943315667430563862">Discord канала: cli-and-tui</a></li>
</ul>
<h2 id="Библиотеки-посочени-в-тази-книга"><a class="header" href="#Библиотеки-посочени-в-тази-книга">Библиотеки, посочени в тази книга</a></h2>
<ul>
<li><a href="https://crates.io/crates/anyhow">anyhow</a> - осигурява <code>anyhow::Error</code> за лесно обработване на грешки</li>
<li><a href="https://crates.io/crates/assert_cmd">assert_cmd</a> - опростява интеграционното тестване на конзолни приложения</li>
<li><a href="https://crates.io/crates/assert_fs">assert_fs</a> - настройва входните файлове и тества изходните файлове</li>
<li><a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a> - добавя <code>--verbose</code> флаг чрез <code>clap</code></li>
<li><a href="https://crates.io/crates/clap">clap</a> - анализатор на аргументите на командния ред</li>
<li><a href="https://crates.io/crates/confy">confy</a> - управление на конфигурацията без шаблони</li>
<li><a href="https://crates.io/crates/crossbeam-channel">crossbeam-channel</a> - осигурява канали за множество собственици и множество потребители за предаване на съобщения</li>
<li><a href="https://crates.io/crates/ctrlc">ctrlc</a> - лесен манипулатор за ctrl-c</li>
<li><a href="https://crates.io/crates/env_logger">env_logger</a> - внедрява регистратор, конфигурируем чрез променливи на средата</li>
<li><a href="https://crates.io/crates/exitcode">exitcode</a> - константи на изходните коде на системата</li>
<li><a href="https://crates.io/crates/human-panic">human-panic</a> - манипулатор на паник съобщения</li>
<li><a href="https://crates.io/crates/indicatif">indicatif</a> - ленти за прогрес и спинери</li>
<li><a href="https://crates.io/crates/is-terminal">is-terminal</a> - открива дали приложението работи в tty</li>
<li><a href="https://crates.io/crates/log">log</a> - осигурява логване, абстрахирано от изпълнението</li>
<li><a href="https://crates.io/crates/predicates">predicates</a> - прилага предикатни функции с булеви стойности</li>
<li><a href="https://crates.io/crates/proptest">proptest</a> - рамка за тестване на свойства</li>
<li><a href="https://crates.io/crates/serde_json">serde_json</a> - sсериализиране/десериализиране към JSON</li>
<li><a href="https://crates.io/crates/signal-hook">signal-hook</a> - обработва UNIX сигнали</li>
<li><a href="https://crates.io/crates/tokio">tokio</a> - за асинхронно изпълнение</li>
<li><a href="https://crates.io/crates/wasm-pack">wasm-pack</a> - инструмент за изграждане на WebAssembly</li>
</ul>
<h2 id="Други-библиотеки"><a class="header" href="#Други-библиотеки">Други библиотеки</a></h2>
<p>Поради постоянно променящия се пейзаж на библиотеките на Rust, добро място за намиране
библиотеки е <a href="https://lib.rs">lib.rs</a>, включително:</p>
<ul>
<li><a href="https://lib.rs/command-line-interface">Интерфейс за конзоли</a></li>
<li><a href="https://lib.rs/config">Конфигурации</a></li>
<li><a href="https://lib.rs/database">Интерфейси за бази данни</a></li>
<li><a href="https://lib.rs/encoding">Кодиране</a></li>
<li><a href="https://lib.rs/filesystem">Файлова система</a></li>
<li><a href="https://lib.rs/web-programming/http-client">HTTP Клиент</a></li>
<li><a href="https://lib.rs/os">Операционна система</a></li>
</ul>
<p>Други ресурси:</p>
<ul>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust Cookbook</a></li>
<li><a href="https://github.com/rosetta-rs">rosetta-rs</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
