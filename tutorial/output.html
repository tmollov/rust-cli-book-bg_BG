<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Изход за хора и машини - Command Line Applications in Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../src/special-content.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Предговор</a></li><li class="chapter-item expanded "><a href="../tutorial/index.html"><strong aria-hidden="true">1.</strong> Приложение за команден ред в рамките на 15 минути</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorial/setup.html"><strong aria-hidden="true">1.1.</strong> Настройване на проекта</a></li><li class="chapter-item expanded "><a href="../tutorial/cli-args.html"><strong aria-hidden="true">1.2.</strong> Анализиране на аргументите подадени на командния ред</a></li><li class="chapter-item expanded "><a href="../tutorial/impl-draft.html"><strong aria-hidden="true">1.3.</strong> Първа имплементация</a></li><li class="chapter-item expanded "><a href="../tutorial/errors.html"><strong aria-hidden="true">1.4.</strong> По-добро отчитане на грешки</a></li><li class="chapter-item expanded "><a href="../tutorial/output.html" class="active"><strong aria-hidden="true">1.5.</strong> Изход за хора и машини</a></li><li class="chapter-item expanded "><a href="../tutorial/testing.html"><strong aria-hidden="true">1.6.</strong> Тестване</a></li><li class="chapter-item expanded "><a href="../tutorial/packaging.html"><strong aria-hidden="true">1.7.</strong> Опаковане и разпространение на Rust инструмент</a></li></ol></li><li class="chapter-item expanded "><a href="../in-depth/index.html"><strong aria-hidden="true">2.</strong> Задълбочени теми</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../in-depth/signals.html"><strong aria-hidden="true">2.1.</strong> Обработка на сигнали</a></li><li class="chapter-item expanded "><a href="../in-depth/config-files.html"><strong aria-hidden="true">2.2.</strong> Използване на конфигурационни файлове</a></li><li class="chapter-item expanded "><a href="../in-depth/exit-code.html"><strong aria-hidden="true">2.3.</strong> Кодове за изход</a></li><li class="chapter-item expanded "><a href="../in-depth/human-communication.html"><strong aria-hidden="true">2.4.</strong> Общуване с хора</a></li><li class="chapter-item expanded "><a href="../in-depth/machine-communication.html"><strong aria-hidden="true">2.5.</strong> Общуване с машини</a></li><li class="chapter-item expanded "><a href="../in-depth/docs.html"><strong aria-hidden="true">2.6.</strong> Рендиране на документация за вашето CLI приложение</a></li></ol></li><li class="chapter-item expanded "><a href="../resources/index.html"><strong aria-hidden="true">3.</strong> Ресурси</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Command Line Applications in Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-cli/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Изход"><a class="header" href="#Изход">Изход</a></h1>
<h2 id="Принтиране-на-hello-world"><a class="header" href="#Принтиране-на-hello-world">Принтиране на “Hello World”</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello World&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Е, това беше лесно.
Страхотно, към следващата тема.</p>
<h2 id="Използване-на-println"><a class="header" href="#Използване-на-println">Използване на <code>println!</code></a></h2>
<p>Можете почти да отпечатате всички неща, който харесвате
с т.нар. макро (macro ) функция - <code>println!</code>.
Макросите имат някои доста невероятни възможности,
но и специален синтаксис.
Той очаква да напишете низов литерал като първи параметър,
който съдържа контейнери, които ще бъдат попълнени
по стойностите на параметрите, които следват като допълнителни аргументи.</p>
<p>Например:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
println!(&quot;My lucky number is {}.&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>ще изпринтира</p>
<pre><code class="language-console">My lucky number is 42.
</code></pre>
<p>Къдравите скоби (<code>{}</code>) в горния низ е един от тези контейнери.
Това е типът заместител по подразбиране
който се опитва да отпечата дадената стойност по разбираем за човека начин.
За числа и низове това работи много добре,
но не всички видове могат да направят това.
Ето защо има и “репрезентиране при дебъгване”,
който можете да получите, като попълните скобите на контейнера по следния начин: <code>{:?}</code>.</p>
<p>Например,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xs = vec![1, 2, 3];
println!(&quot;The list is: {:?}&quot;, xs);
<span class="boring">}
</span></code></pre></pre>
<p>Ще изпринтира:</p>
<pre><code class="language-console">The list is: [1, 2, 3]
</code></pre>
<p>Ако искате вашите собствени типове данни да могат да се отпечатват за дебъгване и логване,
в повечето случаи можете да добавите <code>#[derive(Debug)]</code> над тяхната дефиниция.</p>
<aside>
<p><strong>Забележка:</strong>
“Потребителско-приятно” изпринтиране се извършва с помощта на [<code>Display trait</code>],
изпринтирането при дебъгване (четими за хора, но насочени към разработчиците) използва [<code>Debug trait</code>].
Можете да намерите повече информация за синтаксиса, в който можете да използвате в <code>println!</code>
в <a href="https://doc.rust-lang.org/1.39.0/std/fmt/index.html">документацията за модула <code>std::fmt</code></a>.</p>
</aside>
<h2 id="Изпринтиране-на-грешки"><a class="header" href="#Изпринтиране-на-грешки">Изпринтиране на грешки</a></h2>
<p>Изпринтиране на грешки трябва да се правят чрез <code>stderr</code>
за да улеснят потребителите
и другите инструменти
за препращане на техните изходи към файлове
или повече инструменти.</p>
<aside>
<p><strong>Забележка:</strong>
В повечето операционни системи,
една програма може да пише в два изходни потока, <code>stdout</code> и <code>stderr</code>.
<code>stdout</code> е за действителния изход на програмата,
докато <code>stderr</code> позволява грешките и другите съобщения да се съхраняват отделно от <code>stdout</code>.
По този начин,
изходът може да бъде съхранен във файл или прехвърлен към друга програма
докато грешките се показват на потребителя.</p>
</aside>
<p>В Rust това се постига
с <code>println!</code> и <code>eprintln!</code>,
като първия използва <code>stdout</code> за изход,
а последния <code>stderr</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;This is information&quot;);
eprintln!(&quot;This is an error! :(&quot;);
<span class="boring">}
</span></code></pre></pre>
<aside>
<p><strong>Внимавайте</strong>: Изпринтирането на т.нар. <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">escape codes</a> може да е опасно,
поставяйки терминала на потребителя в странно състояние.
Винаги внимавайте, когато ги отпечатвате ръчно!</p>
<p>В идеалния случай трябва да използвате библеотеки като <code>ansi_term</code>
при работа със необработени <code>escape codes</code>
, за да направите живота ви (и на вашия потребител) по-лесен.</p>
</aside>
<h2 id="Бележка-относно-ефективността-на-изпринтиране"><a class="header" href="#Бележка-относно-ефективността-на-изпринтиране">Бележка относно ефективността на изпринтиране</a></h2>
<p>Изпринтирането към терминала е изненадващо бавен!
Ако извикате неща като <code>println!</code> в цикъл,
лесно може да се превърне в пречка в иначе бърза програма.
За да ускорите това,
има две неща, които можете да направите.</p>
<p>Първо,
може да искате да намалите броя на изпринтиранията
които всъщност се “заливат” към терминала.
<code>println!</code> казва на системата да “залива” терминала <em>всеки</em> път,
тъй като е обичайно да се отпечатва всеки на нов ред.
Ако нямате нужда от това,
можете да увиете своя <code>stdout</code> заявка в <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufWriter.html"><code>BufWriter</code></a>
който по подразбиране буферира до 8 kB.
(Все още можете да извикате функцията <code>.flush()</code> на този <code>BufWriter</code>
когато е нужно да изпринтирате незабавно.)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let mut handle = io::BufWriter::new(stdout); // optional: wrap that handle in a buffer
writeln!(handle, &quot;foo: {}&quot;, 42); // add `?` if you care about errors here
<span class="boring">}
</span></code></pre></pre>
<p>Второ,
помага за придобиване на заключване на <code>stdout</code> (или <code>stderr</code>)
и използване на функцията <code>writeln!</code> за да отпечатате директно.
Това предотвратява заключването и отключването на <code>stdout</code> отново и отново.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let mut handle = stdout.lock(); // acquire a lock on it
writeln!(handle, &quot;foo: {}&quot;, 42); // add `?` if you care about errors here
<span class="boring">}
</span></code></pre></pre>
<p>Можете също така да комбинирате двата подхода.</p>
<h2 id="Показване-на-лента-за-напредък"><a class="header" href="#Показване-на-лента-за-напредък">Показване на лента за напредък</a></h2>
<p>Някои CLI приложения работят по-малко от секунда,
други отнемат минути или часове.
Ако пишете един от последните типове програми,
може да искате да покажете на потребителя, че нещо се случва.
За целта трябва да опитате да отпечатате полезни актуализации на състоянието,
в идеалния случай във форма, която може лесно да се консумира.</p>
<p>Използвайки библеотеката <a href="https://crates.io/crates/indicatif">indicatif</a>,
можете да добавите ленти за напредък
и малки спинери към вашата програма.
Ето един бърз пример:</p>
<pre><code class="language-rust ignore">fn main() {
    let pb = indicatif::ProgressBar::new(100);
    for i in 0..100 {
        do_hard_work();
        pb.println(format!(&quot;[+] finished #{}&quot;, i));
        pb.inc(1);
    }
    pb.finish_with_message(&quot;done&quot;);
}
</code></pre>
<p>Посетете <a href="https://docs.rs/indicatif">документацията</a>
и <a href="https://github.com/console-rs/indicatif/tree/main/examples">примерите</a>
за повече информация.</p>
<h2 id="Логване"><a class="header" href="#Логване">Логване</a></h2>
<p>За да разберем по-лесно какво се случва в нашата програма,
може да искаме да добавим някои регистрационни отчети - логове.
Това обикновено е лесно, докато пишете вашата програма.
Но ще стане супер полезно, когато стартирате тази програма отново след половин година.
В известно отношение,
логването е същото като използването <code>println!</code>,
за разлика от това, че можете да посочите важността на съобщението.
Нивата, които обикновено можете да използвате са: <em>error</em>, <em>warn</em>, <em>info</em>, <em>debug</em>, и <em>trace</em>
(<em>error</em> има най-висок приоритет, <em>trace</em> най-ниската).</p>
<p>За да добавите просто логване към вашето приложение,
ще ви трябват две неща:
Библеотеката <a href="https://crates.io/crates/log">log</a> (това съдържа макроси, именувани на нивата за логване)
и <em>адаптер</em> което всъщност записва изхода от логовете някъде полезно.
Възможността да използвате адаптери за логване на файлове е много гъвкава:
Можете например да ги използвате за записване на лог файлове не само в терминала
но също и към <a href="https://en.wikipedia.org/wiki/Syslog">syslog</a> или към централен сървър за логове.</p>
<p>Тъй като в момента се занимаваме само с писането на CLI приложение,
лесен за използване адаптер е <a href="https://crates.io/crates/env_logger">env_logger</a>.
Нарича се “env” логер защото можете да използвате
променлива на средата, за да посочите кои части от вашето приложение
искате да логвате
(и на кое ниво искате да ги логвате).
Той ще префиксира вашите съобщения в логовете с времеви печат
и модула, откъдето идват съобщенията.
Тъй като библиотеките също могат да използват <code>log</code>,
вие лесно можете да конфигурирате и изхода им в логовете.</p>
<p>Ето един бърз пример:</p>
<pre><code class="language-rust ignore">use log::{info, warn};

fn main() {
    env_logger::init();
    info!(&quot;starting up&quot;);
    warn!(&quot;oops, nothing implemented!&quot;);
}
</code></pre>
<p>Ако приемем, че имате този файл като <code>src/bin/output-log.rs</code>,
в Linux и macOS, можете да го стартирате така:</p>
<pre><code class="language-console">$ env RUST_LOG=info cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>В Windows PowerShell, можете да го стартирате така:</p>
<pre><code class="language-console">$ $env:RUST_LOG=&quot;info&quot;
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>В Windows CMD, можете да го стартирате така:</p>
<pre><code class="language-console">$ set RUST_LOG=info
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p><code>RUST_LOG</code> е името на променливата в средата, който
можете да използвате, за да зададете настройките на вашите логвания.
<code>env_logger</code> съдържа конструктор
така че програмно да коригирате тези настройки
и, например, за показване на съобщения от <em>info</em> ниво по подразбиране.</p>
<p>Има много алтернативни адаптери за логване,
както и алтернативи или разширения на <code>log</code>.
Ако знаете, че вашето приложение ще има много за логване,
не забравяйте да ги прегледате,
и улеснете живота на вашите потребители.</p>
<aside>
<p><strong>Съвет:</strong>
Опитът показва, че дори леко полезните CLI програми могат да се окажат използвани години наред.
(Особено ако са предназначени като временно решение.)
Ако приложението ви не работи
и някой (например вие в бъдеще) трябва да разбере защо,
да сте в състояние да подадете командата <code>--verbose</code>, за да получите допълнителен лог изход
може да направи разликата между минути и часове отстраняване на грешки.
Библеотеката <a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a> съдържа бърз начин
за добавяне на командата <code>--verbose</code> на проект ако използва <code>clap</code>.</p>
</aside>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tutorial/errors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../tutorial/testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tutorial/errors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../tutorial/testing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
